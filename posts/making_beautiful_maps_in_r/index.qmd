---
title: "Making Beautiful Maps in R"
date: "01/04/2025"
abstract-title: "ABSTRACT"
abstract: "Creating maps using a programming language can be a painful process. The lack of a visual editor with realtime, crisp feedback makes stylistic changes and minute updates difficult. Further, R coders often find that the moment they have perfected the visuals of the map in the RStudio viewer, they realised that the saved version of the map has different proportions and sizes! In this blog I explore the R package 'tmap' and how it can be used to programmatically make beautiful, report ready maps, with as little stress as possible."
image: "image.png"
format: html
title-block-banner: true #This is our banner
include-after-body: "../../html/html_footer.html" #This is our footer
---

```{r}
#| output: FALSE
#| echo: FALSE
#| code-fold: TRUE

library(tmap)
library(dplyr)

```

# Introduction

TBD

# A Visually Appealing Map

TBD

## Prepare the Datasets

### Background

```{r}

library(sf)

#load in the background data
background <- read_sf("Europe_coastline_poly.shp")

#change the crs of the background data to match our Netherlands dataset
background <- st_transform(background, st_crs(NLD_prov))
                      
#create a single polygon of the province dataset
NLD_prov_single <- st_union(NLD_prov)

#remove any holes within the polygon then make the shape valid
NLD_prov_single <- nngeo::st_remove_holes(NLD_prov_single) |> 
  st_make_valid()
                      
#take the full background dataset and cut a hole out of the same as the single polygon of the NLD_prov
background_no_NLD <- st_difference(background, NLD_prov_single)

#take the background with a hole in in, a crop it to a buffered bbox of the NLD_prov dataset (reduce file size)
background_final <- st_intersection(background_no_NLD, st_as_sfc(st_bbox(st_buffer(NLD_prov_single, 20000))))

```

### France/World

```{r}

world_background <- World

france_test <- world_background |> 
  filter(name == "France") |> 
  st_cast("POLYGON") |> 
  mutate(ID = row_number())


tm_shape(france_test) +
  tm_polygons(fill = "ID",
              fill.scale = tm_scale_categorical())


france_test <- france_test |> 
  select(name, iso_a3)


world_no_france <- world_background |> 
  filter(name != "France") |> 
  select(name, iso_a3)

world_final <- rbind(world_no_france, france_test)

```

## Create the Inset Map

```{r}

library(grid)

#create a bounding box of the municipality dataset
NLD_bbox <- st_as_sfc(st_bbox(NLD_muni))

#create a much larger buffer of the municipality dataset to set the perspective of the map
NLD_positioning <- st_as_sfc(st_bbox(st_buffer(NLD_muni, dist = 1000000)))

#create the map that will be put into the viewport
inset_map <- tm_shape(NLD_positioning, is.main = TRUE) +
  tm_polygons(fill_alpha = 0,
              col_alpha = 0) +
  tm_shape(world_final) +
  tm_polygons(fill = "#99B5B1") +
  tm_text(text = "iso_a3",
          size = 0.3,
          options = opt_tm_text(shadow = T,
                                shadow.offset.x = 0.01,
                                shadow.offset.y = 0.01)) +
  tm_shape(NLD_bbox) +
  tm_borders(lwd = 2, 
             col = "#8E3B46") +
  tm_layout(asp = 0,
            bg.color = "#C1DEEA",
            outer.bg.color = "#F2F2F2") 

```



```{r}

inset_map

tmap_save(inset_map, "inset_map.png")

```

## Create the Main Map

```{r}
  
# install.packages("remotes")
#remotes::install_github("r-tmap/tmap")

prov_2 <- NLD_prov |> 
  mutate(UseMe = "Province")

dist_2 <- NLD_dist |> 
  mutate(population = population+1)

muni_2 <- NLD_muni |> 
  mutate(UseMe = "Municipality")


map <- tm_shape(background_final) +
  tm_polygons(fill = "#99B5B1") +
  tm_shape(dist_2, is.main = T) +
  tm_polygons(fill = "population",
              fill.scale = tm_scale_continuous_log(values = c("#FFFFFF", "#00252A"),
                                                   ticks = c(1, 10000, 100000)),
              fill.legend = tm_legend(title = "Population",
                                      position = tm_pos_out("right", "center"),
                                      title.color = "black",
                                      reverse = TRUE),
              col_alpha = 0) +
  tm_shape(muni_2) +
  tm_borders(col = "UseMe",
             col.scale = tm_scale_categorical(values = "#e6aa04"),
             col.legend = tm_legend(title = "",
                                    position = tm_pos_out("right", "center"),
                                    lwd = 2),
             lwd = 1) +
  tm_shape(prov_2) +
  tm_borders(col = "UseMe", 
             col.scale = tm_scale_categorical(values = "#8E3B46"),
             col.legend = tm_legend(title = "",
                                    position = tm_pos_out("right", "center")),
             lwd = 2) +
  tm_layout(bg.color = "#C1DEEA",
            legend.bg.color = "white",
            asp = 0,
            outer.bg.color = "#F2F2F2") +
  tm_credits("Credits Text", 
             position = c("left", "bottom")) +
  tm_compass(type = "rose", 
             position = c("LEFT", "TOP"),
             color.dark = "black", 
             color.light = "white",
             size = 3.5)

```


```{r}

map

```


```{r}


#figure out where to place the view port
inset_viewport <- viewport(y = 0.015, x = 0.98, width = 0.33, height = 0.33, just = c("right", "bottom"))

#save map
tmap_save(map, "final_map.png", insets_tm = inset_map, insets_vp = inset_viewport, height = 6, width = 8)


```











