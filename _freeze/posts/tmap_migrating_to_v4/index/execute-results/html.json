{
  "hash": "f69c136f7200a2304912a5007fb8a6ce",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Migrating to Version 4 of the tmap R Package\"\ndate: \"01/04/2025\"\nabstract-title: \"ABSTRACT\"\nabstract: \"My favourite mapping package just released a major update! In this post I discuss the changes made as they relate to my work, and provide some tips and tricks I have learnt so far when migration from Version 3.0 to Version 4.0.\"\nimage: \"image.png\"\nformat: html\ntitle-block-banner: true #This is our banner\ninclude-after-body: \"../../html/html_footer.html\" #This is our footer\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n# Introduction\n\nThe tmap package is one of my all time favourite R packages, and this latest update only solidified this opinion. I highly recommend that you check out the main page [here](https://r-tmap.github.io/tmap/index.html), and take the time to read over some of the documents in each of the tabs. \n\nAs of the 27th of January, 2025, tmap version 4.0 was released, and with it came some BIG changes. The authors have done a great job making sure that the update is backwards compatible with your current code, however moving forward it is very important to start doing things the \"new\" way, as the \"old\" way will no longer be receiving updates. One of the most impactful updates in my opinion, is changes to the syntax used within a lot of the core functions. This new syntax makes things easier to understand, cleaner, and provides greater flexibility in the creation of your maps. However it can be a confusing journey to undergo the transition. You will find that for alot of the old v3 code there are now warning/pop-up messages to help you with the transition, but there are a few things that slip few the cracks and I think it is sometimes just easier to see some examples. Below I run through how my code for making maps using tmap used to look, and then discuss the changes that have happened and how things look now! \n\n:::{.callout-note}\nNew datasets have also been added for demonstration purposes as well as the ability to extent tmap (to do things like map very unique spatial data types, or creating map overlays in a 3D environment). We won't be covering those in this blog, but they are very interesting in their own right.\n:::\n\n# How things Used to Look\n\n:::{.callout-note}\nFor the purposes of this blog I will assume a basic understanding of the tmap package and won't be explaining in detail what each function is/does.\n:::\n\nRight, so in version 3.0, how did things look? Well, if I'm honest they looked a little messy. I found that there was only a moderate level of consistency between the arguments in each function, and that arguments within a function that match together didn't always make that fact obvious. For example, lets look at the arguments in the `tm_polygons()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_polygons(col,\n            border.col,\n            alpha,\n            palette,\n            legend.show,\n            ...)\n```\n:::\n\n\n\n\n:::{.callout-note}\nThere are many more arguments in `tm_polygons()` than what I have listed above, but the general idea remains the same for the arguments I haven't listed.\n:::\n\n... seems fine I guess. But what if I now add in the `tm_borders()` function:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_borders(col,\n           ...)\n```\n:::\n\n\n\n\nOkay so now we need the additional context of knowing that \"col\" in `tm_polygons()` changes the colour inside the polygon, where as \"col\" in `tm_borders()` changes the colour of the border of the polygon. (See how `tm_polygons()` also has a \"border.col\" argument). Confusing! Moving on, lets look at the alpha (transparency) argument. Does that change the alpha of the col or the border? You would have to read the documentation to know that. What about the palette argument? Col or Border?... Extra confusing. But it gets worse! There is only one palette argument, so how do you change the palette for the inside of the polygon independently to the palette for the border of the polygons. You can't, so you must use the `tm_polygons()` and `tm_borders()` functions together. Just making the conflict between \"col\" more obvious. Arrgh!\n\nEnough ranting, lets look at a worked example of a map made using tmap version 3.0:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract a subset of dat from the dataset provided with the tmap package\nexample_data <- NLD_muni |> \n  filter(province == \"Fryslan\")\n\n#create a map using the version 3.0 syntax\nv3_map <- tm_shape(example_data) +\n  tm_polygons(col = \"name\", border.col = \"black\", alpha = 0.8, palette = \"Pastel1\", legend.show = T) +\n  tm_text(\"name\", shadow = T, auto.placement = T, size = 0.6) +\n  tm_shape(example_data) +\n  tm_borders(\"name\") +\n  tm_layout(legend.bg.color = \"white\", legend.frame.color = \"black\", asp = 1.1,\n            legend.outside = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print the map\nv3_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n# How Things Look Now\n\nIn comparison to the version 3 code required to produce this map, the new syntax available with tmap version 4 is much more consistent, concise, and also somehow does more with less. For example, lets look at the arguments in the `tm_polygons()` function again, right now we will just replace 1 to 1 the arguments we looked at before:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_polygons(fill, #this was \"col\"\n            col, #this was \"border.col\"\n            fill_alpha, #this was \"alpha\"\n            fill.scale, #this was \"palette\"\n            fill.legend, #this was \"legend.show\"\n            ...)\n```\n:::\n\n\n\n\nAt first glance this doesn't seem a whole lot better, there are now just a lot of \"fill\" arguments. But lets have a look at `tm_borders()` now:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_borders(col, #this was \"col\", and still is \"col\"\n           ...)\n```\n:::\n\n\n\n\nRight away we can see the first problem has been addressed. \"Col\" now always refers to the colour of the line/outline/border, whereas \"fill\" always refers to the inside/fill of the shape. Secondly, the confusion around alpha has been removed, we can see that \"alpha\" is now \"fill_alpha\", but even cooler, there is actually also a \"col_alpha\" now, the alphas' are independent! The same logic has been applied to \"palette\", which is now \"fill.scale\" (we will cover the change from palette to scale later), and the legend arguments, which now have \"fill\" in front of them. So what we have now is something like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_polygons(fill, #what variable defines the \"fill\" of the polygons\n            fill.scale, #what palette, breaks, style, etc. should the be used to colour the polygons\n            fill.legend, #do you want a legend? What should it look like for the fill variable\n            fill.free, #should the scale be free for multiples (facets etc.)\n            fill_alpha, #how transparent should the fill colour be\n            col, #what variable defines the \"col\" (border) of the polygons\n            col.scale, #what palette, breaks, style, etc. should the be used to colour the borders\n            col.legend, #do you want a legend? What should it look like for the col variable\n            col.free, #should the scale be free for multiples (facets etc.)\n            col_alpha, #how transparent should the border colour be\n            ...)\n```\n:::\n\n\n\n\nIt could not be more obvious what each argument does now. Lets now make the same map as above, but this time with the version 4.0 syntax:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a map using the version 4.0 syntax\nv4_map <- tm_shape(example_data) +\n  tm_polygons(fill = \"name\", \n              fill.scale = tm_scale_categorical(values = \"brewer.pastel1\"),\n              fill.legend = tm_legend(show = T),\n              fill_alpha = 0.8,\n              col = \"name\",\n              col.scale = tm_scale_categorical(values = \"brewer.set2\"),\n              col.legend = tm_legend(show = T)) +\n  tm_text(\"name\", \n          size = 0.6,\n          options = opt_tm_text(shadow = TRUE, \n                                point.label = TRUE)) +\n  tm_layout(legend.bg.color = \"white\",\n            legend.frame.color = \"black\",\n            legend.outside.position = tm_pos_out(\"right\", \"top\"),\n            asp = 1.1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#print the map\nv4_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\nIgnoring the fact that this isn't the most visually appealing map, it is now very easy to isolate exactly what each argument does and how we can adjust different aspects of the map.\n\n# A Visually Appealing Map\n\nI think it is now about time to produce a map that is actually visually appealing!\n\n:::{.callout-note}\nThere is a lot happening in the code for this map. If you're interested in learning whats going on, I break it down in detail over in my other blog post: [LINK]\n:::\n\n## Prepare the Datasets\n\n### Background\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load packages required\nlibrary(sf)\n\n#load in the background data\nbackground <- read_sf(\"Europe_coastline_poly.shp\")\n\n#change the crs of the background data to match our Netherlands dataset\nbackground <- st_transform(background, st_crs(NLD_prov))\n                      \n#create a single polygon of the province dataset\nNLD_prov_single <- st_union(NLD_prov)\n\n#remove any holes within the polygon then make the shape valid\nNLD_prov_single <- nngeo::st_remove_holes(NLD_prov_single) |> \n  st_make_valid()\n                      \n#take the full background dataset and cut a hole out of the same as the single polygon of the NLD_prov\nbackground_no_NLD <- st_difference(background, NLD_prov_single)\n\n#take the background with a hole in in, a crop it to a buffered bbox of the NLD_prov dataset (reduce file size)\nbackground_final <- st_intersection(background_no_NLD, st_as_sfc(st_bbox(st_buffer(NLD_prov_single, 60000))))\n```\n:::\n\n\n\n\n### France/World\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#get the full world dataset\nworld_background <- World\n\n#extract France from the dataset\nfrance_test <- world_background |> \n  filter(name == \"France\")\n\n#view the france dataset (to demonstrate the naming issue)\ntm_shape(france_test) +\n  tm_polygons(fill.scale = tm_scale_categorical()) +\n  tm_text(text = \"iso_a3\",\n          size = 1,\n          options = opt_tm_text(shadow = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#convert france to a individual polygons\nfrance_test <- france_test |> \n  st_cast(\"POLYGON\") |> \n  mutate(ID = row_number())\n\n#view the france dataset (to demonstrate the naming issue)\ntm_shape(france_test) +\n  tm_polygons(fill = \"ID\",\n              fill.scale = tm_scale_categorical()) +\n  tm_text(text = \"iso_a3\",\n          size = 1,\n          options = opt_tm_text(shadow = T))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#select the core columns we need\nfrance_test <- france_test |> \n  select(name, iso_a3)\n\n#remove france from the original world dataset and select the core columns we need\nworld_no_france <- world_background |> \n  filter(name != \"France\") |> \n  select(name, iso_a3)\n\n#join france back to the world dataset (sans france)\nworld_final <- rbind(world_no_france, france_test)\n```\n:::\n\n\n\n\n## Create the Inset Map\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load the required packages\nlibrary(grid)\n\n#create a bounding box of the municipality dataset\nNLD_bbox <- st_as_sfc(st_bbox(NLD_muni))\n\n#create a much larger buffer of the municipality dataset to set the perspective of the inset map\nNLD_positioning <- st_as_sfc(st_bbox(st_buffer(NLD_muni, dist = 1500000)))\n\n#create the inset map that will be put into the viewport\ninset_map <- tm_shape(NLD_positioning, is.main = TRUE) +\n  tm_polygons(fill_alpha = 0,\n              col_alpha = 0) +\n  tm_shape(world_final) +\n  tm_polygons(fill = \"#99B5B1\") +\n  tm_text(text = \"iso_a3\",\n          size = 0.3,\n          options = opt_tm_text(shadow = T,\n                                shadow.offset.x = 0.01,\n                                shadow.offset.y = 0.01)) +\n  tm_shape(NLD_bbox) +\n  tm_borders(lwd = 2, \n             col = \"#8E3B46\") +\n  tm_layout(asp = 0,\n            bg.color = \"#C1DEEA\",\n            outer.bg.color = \"#F2F2F2\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#view the inset map\ninset_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#save the inset map\ntmap_save(inset_map, \"inset_map.png\")\n```\n:::\n\n\n\n\n## Create the Main Map\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#for some reason the v4 and v4.1 layouts are slightly different. So we will use the 4.1 layout to get ahead of future changes\n#remotes::install_github(\"r-tmap/tmap\")\n\n#access the netherlands province data\nprov_2 <- NLD_prov |> \n  mutate(UseMe = \"Province\")\n\n#access the netherlands district data\ndist_2 <- NLD_dist |> \n  mutate(population = population+1)\n\n#access the netherlands municipality data\nmuni_2 <- NLD_muni |> \n  mutate(UseMe = \"Municipality\")\n\n#create the map\nmap <- tm_shape(background_final) +\n  tm_polygons(fill = \"#99B5B1\") +\n  tm_shape(dist_2, is.main = T) +\n  tm_polygons(fill = \"population\",\n              fill.scale = tm_scale_continuous_log2(values = c(\"#FFFFFF\",\"#00252A\"),\n                                                   ticks = c(1, 10000, 100000)),\n              fill.legend = tm_legend(title = \"Population:\",\n                                      position = tm_pos_out(\"right\", \"center\"),\n                                      title.color = \"black\",\n                                      reverse = TRUE),\n              col_alpha = 0) +\n  tm_shape(muni_2) +\n  tm_borders(col = \"UseMe\",\n             col.scale = tm_scale_categorical(values = \"#E6AA04\"),\n             col.legend = tm_legend(title = \"\",\n                                    position = tm_pos_out(\"right\", \"center\"),\n                                    lwd = 2),\n             lwd = 1) +\n  tm_shape(prov_2) +\n  tm_borders(col = \"UseMe\", \n             col.scale = tm_scale_categorical(values = \"#8E3B46\"),\n             col.legend = tm_legend(title = \"\",\n                                    position = tm_pos_out(\"right\", \"center\")),\n             lwd = 2) +\n  tm_layout(bg.color = \"#C1DEEA\",\n            legend.bg.color = \"white\",\n            asp = 0,\n            outer.bg.color = \"#F2F2F2\") +\n  tm_credits(\"© Data: Statistics Netherlands, Software: R-tmap\", \n             position = c(\"LEFT\", \"BOTTOM\"),\n             size = 0.5) +\n  tm_compass(type = \"rose\", \n             position = c(\"LEFT\", \"TOP\"),\n             color.dark = \"black\", \n             color.light = \"white\",\n             size = 3.5)\n\n\n#add major cities:\n\n#Amsterdam, Rotterdam, The Hague, and Utrecht.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#view the map\nmap\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#save the map\ntmap_save(map, \"main_map.png\", height = 6, width = 8)\n```\n:::\n\n\n\n\n## Arrange Maps\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#figure out where to place the view port\ninset_viewport <- viewport(y = 0.015, x = 0.98, width = 0.33, height = 0.33, just = c(\"right\", \"bottom\"))\n\n#save map\ntmap_save(map, \"combined_map.png\", insets_tm = inset_map, insets_vp = inset_viewport, height = 6, width = 8)\n```\n:::\n\n\n\n\n# Some Other Subtle Changes\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#map <- tm_shape(seagrass, is.master = T) +\n#  tm_borders(alpha = 0) +\n#  tm_shape(qld) +\n#  tm_polygons(col = \"grey80\") +\n#  tm_shape(dt_background) +\n#  tm_polygons(col = \"grey90\", border.col = \"black\") +\n#  tm_shape(dt_marine) +\n#  tm_polygons(col = \"Geographic Area: All\", border.col = \"black\", alpha = 0.3, palette = \"Pastel1\", legend.show = T) +\n#  water_map +\n#  tm_shape(tsv) +\n#  tm_symbols(size = 0.3, col = \"white\", border.col = \"black\", border.lwd = 1, shape = 23) +\n#  tm_text(\"PlaceName\", shadow = T, auto.placement = T, size = 0.6) +\n#  tm_shape(seagrass) +\n#  tm_polygons(col = \"Meadow ID\", palette = \"Set3\", border.col = \"black\", legend.show = F) +\n#  tm_text(\"Meadow ID\", shadow = T, auto.placement = T, size = 1.5) +\n#  tm_layout(legend.bg.color = \"white\", legend.frame = \"black\", asp = 1.1,\n#            legend.position = c(\"left\", \"bottom\"))\n```\n:::\n\n\n\n\n\n\nMain points to hit\n\n - demonstrate I can do mapping\n - show some things i used to do\n - show how i have updated those things\n \n \n Here is an example of what i used to do:\n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #build on these two layers with customization\n```\n:::\n\n\n\n\nthings i have noticed\n\n - is.master is now is.main. doesn't seem to be a note of that one\n - auto.placement is now under opt_tm_text(point.label = T)\n - shadow is now under opt_tm_text(shadow = T)\n - organisation is much cleaner now, all the fill.xyz can be put together and it is easy to spot which arguments relate to one another\n - setting colours and styles makes much more sense now. doing the cat vs cont, and setting the palette etc.\n - my preferred lay out has changed. I now like to list each argument under the next - helps with grouping but does make code have more lines\n \n \n rasters have also changed alot.\n \n before:\n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#map <- tm_shape(qld) +\n#        tm_polygons(col = \"grey80\", border.col = \"black\") +\n#        tm_shape(get(bas_map_type[j]), is.master = T) +\n#        tm_raster(legend.reverse = T, palette = pal_type[j], midpoint = mid_type[[j]], style = \"fixed\", breaks = get(break_type[j])) \n```\n:::\n\n\n\n \n \nafter:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  tm_shape(qld) +\n#      tm_polygons(fill = \"grey80\", \n#                  col = \"black\") +\n#      tm_shape(get(reg_map_type[j]), is.main = T) +\n#      tm_raster(col.scale = tm_scale_intervals(style = \"fixed\",\n#                                               breaks = get(break_type[j]),\n#                                               midpoint = mid_type[[j]],\n#                                               values = pal_type[j]),\n#                col.legend = tm_legend(reverse = T))\n```\n:::\n\n\n\n \n\nfacet is much easier.\n\nbefore:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#using unique regions\nfor (i in n3_marine_names) {\n  \n  #filter all basins by region\n  region_basins <- n3_marine_region |> filter(Region == i)\n  \n  #get the associated basins\n  basins <- n3_basins |> filter(Region == i)\n  \n  #create counter for j loop\n  count <- 0\n  \n  #using years vector created by data sourcing script\n  for (j in time(n3_dhw_5y)){\n    \n    #track counter\n    count <- count + 1\n    \n    #mask to the specific region and year\n    single_year_region <- trim(mask(n3_dhw_5y[[time(n3_dhw_5y) == j]], vect(region_basins)))\n  \n    #for the first map make a legend\n    if (count == 1){\n      \n      #plot\n      map <- tm_shape(single_year_region) +\n        tm_raster(palette = dhw_cols, breaks = c(1:6), labels = dhw_lab) +\n        tm_shape(qld) +\n        tm_polygons(col = \"grey80\", border.col = \"black\") +\n        tm_shape(region_basins, is.master = T) +\n        tm_borders(col = \"black\") +\n        tm_shape(basins) +\n        tm_polygons(col = \"grey90\", border.col = \"black\") +\n        tm_layout(asp = 5, legend.show = F, main.title = year(time(single_year_region)), main.title.position = \"centre\")\n      \n      #save the map\n      assign(glue(\"map{count}\"), map)\n      \n      #make a legend map\n      legend_map <- tm_shape(single_year_region) + \n        tm_raster(palette = dhw_cols, breaks = c(1:6), labels = dhw_lab, legend.reverse = T, \n                  title = \"Coral bleaching likelihood \\n and number of DHW's\") +\n        tm_layout(legend.only = T, legend.title.size = 3,\n                  legend.text.size = 1.6, legend.position = c(0, 0.3))\n      \n    #otherwise, no legend\n    } else {\n        \n      #plot\n      map <- tm_shape(single_year_region) +\n        tm_raster(palette = dhw_cols, breaks = c(1:6), labels = dhw_lab) +\n        tm_shape(qld) +\n        tm_polygons(col = \"grey80\", border.col = \"black\") +\n        tm_shape(region_basins, is.master = T) +\n        tm_borders(col = \"black\") +\n        tm_shape(basins) +\n        tm_polygons(col = \"grey90\", border.col = \"black\") +\n        tm_layout(asp = 5, legend.show = F, main.title = year(time(single_year_region)), main.title.position = \"centre\")\n      \n      #save the map\n      assign(glue(\"map{count}\"), map)\n        \n    }\n  }  \n  \n  #arrange into two rows\n  facet_map <- tmap_arrange(map1, map2, map3, map4, map5, nrow = 2)\n  \n  #edit variable name for better save path\n  i_lower <- tolower(gsub(\" \", \"-\", i))\n \n  #save the map as a png\n  tmap_save(facet_map, filename = glue(\"{output_path}/plots/{i_lower}_dhw_fyear-{current_fyear}-to-{current_fyear-4}.png\"))\n  \n  #save the legend seperately\n  tmap_save(legend_map, glue(\"{output_path}/plots/{i_lower}_dhw_fyear-{current_fyear}-to-{current_fyear-4}_legend.png\"))\n  \n}\n```\n:::\n\n\n\n\nafter:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot\n  facet_map <- tm_shape(all_year_region) +\n    tm_raster(col.scale = tm_scale_intervals(values = dhw_cols, \n                                             breaks = c(1:6),\n                                             labels = dhw_lab),\n              col.free = FALSE,\n              col.legend = tm_legend(title = \"Coral bleaching likelihood and number of DHW's\")) +\n    tm_shape(qld) +\n    tm_polygons(fill = \"grey80\",\n                col = \"black\") +\n    tm_shape(region_basins, is.main = T) +\n    tm_borders(col = \"black\") +\n    tm_shape(basins) +\n    tm_polygons(fill = \"grey90\", \n                col = \"black\") +\n    tm_layout(panel.labels = year(time(n3_dhw_5y))) +\n    tm_facets_hstack()\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}