{
  "hash": "b719c088ad71d7e057615ee0de651be5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Making Beautiful Maps in R\"\ndate: \"01/04/2025\"\nabstract-title: \"ABSTRACT\"\nabstract: \"Creating maps using a programming language can be a painful process. The lack of a visual editor with realtime feedback, varying proportions between console and outputs, and complicated syntax to tie your brain in knots! In this blog I explore the R package 'tmap' and how it can be used to programmatically make beautiful, report ready maps, with as little stress as possible.\"\nimage: \"image.png\"\nformat: html\ntitle-block-banner: true #This is our banner\ninclude-after-body: \"../../html/html_footer.html\" #This is our footer\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Introduction\n\nThe art of the map is an ancient skill, since the age of movement has the requirement of orientation been required. Just ask the first lobe-finned fishes from over 365 million years ago. Without maps, how would they have known to walk out of the ocean!\n\nSeriously though the human race has been making maps since forever, and there is just something so en-capturing about it. The ability to create a useful and visually map is incredible fun, however knowing where to start can be daunting. There are just so many options, most of which are incredibly complicated, expensive, or time consuming. Just to name a few you have ArcGIS, QGIS, Google Maps, Mapbox, Inkscape, and R. Where to start? What to choose?\n\nToday I'd like to share how I create my maps using R. We will cover a range of things including:\n\n - Why I use R over other programs,\n - What are the requirements of creating maps in R,\n - What other programs I use to help me along the way,\n - The type of code you can expect to write for maps.\n \nAnd at the end of all this, I will walk through the exact code used to produce this map:\n\n![Netherlands Population Map](final_map.png)\n \nLets get right into it.\n\n# Why R?\n\nR... it might not be immediately obviously why I use R to create my maps, and I don't blame you for thinking that. Its a programming language, it doesn't have a visual editor, its created for statistical analysis! So why?...\n\nThere a few reason that sell it for me:\n\n 1. I already use R, and if I do say so myself I'm quite proficient. But more importantly, it means I can transition from statistical analysis to spatial analysis seamlessly. No need to export the data and load it somewhere else.\n 2. R is programmatic. A lot of the time I find that I need to create multiple maps with almost the same styling. R makes this easy due to its programmatic nature.\n 3. Control. Once you understand mapping in R, the control you have over the design is immense. Almost anything can be adjusted.\n 4. Range. R has a surprisingly wide range of mapping capabilities. Did you know you can:\n    4.1 Create interactive maps\n    4.2 Create 3D maps\n    4.3 Map every type of spatial object (netcdf, raster, vector, dem, etc.)\n    4.4 Embed maps in shiny applications\n\nAnd I'll tell you a little secret. I still use ArcGIS and QGIS, but mostly as support tools.\n\n## Requirements to Map in R\n\nTo map in R you only need a couple of things. You need your spatial data (duh), you need to decide on the R package you want to use for mapping (a bit harder), and you need patience (difficulty level: 100).\n\nPicking the right R package might seem hard, there are a lot of options including ggplot2, leaflet, mapview, tmap, and ggmap, however, I'll make it easy. Pick tmap. The syntax makes sense, it has almost 100% coverage of things you would want to do, and it recently got a great update. Sorted.\n\n## Other Helpful Programs\n\nAs I noted above, I don't restrict myself to just R for maps, I also use ArcGIS and QGIS, because there are some things that R is just never going to be able to do well. For example, StoryMaps by ESRI (ArcGIS) - which are online interactive experiences that include excellent mapping tools. StoryMaps are great for education and outreach, and to take the reader on a journey. StoryMaps are not good for creating maps for you scientific reports. Additionally, I use QGIS for quick visualizations, you can simply drag and drop your data and instantly see what it looks like - no code necessary.\n\n# Code To Make Maps In R\n\nWith that monologue out of the way lets start exploring the code you can expect to encounter when creating your maps in R. For the purposes of this blog, my objective is to create a visually interesting map that demonstrates several of the key skills needed for great maps. We will look at selecting colour palettes and styling, manipulating spatial data to create complimentary layers, adding extra components like a legend, and north arrow, fixing common problems encountered while mapping, and finally - adding inset maps to provide a global/country scale reference. \n\n:::{.callout-note}\nPlease note that the exact content of the map is secondary. The data used comes with the tmap package and is generally just used for practice and experimentation.\n:::\n\n## Find the Datasets\n\nThe first thing you always want to do when making maps is to gather up all of the data you want to use. You might scoff at how obvious this seems, but you would be surprised how often you get halfway through designing the style of your core layer and you realise, wait... I don't have a layer for the background. For the map we are going to make today, we have several datasets:\n\n - The core layer: \"Netherlands Province\"\n - The supporting layers;\n    + \"Netherlands Municipality\"\n    + \"Netherlands District\"\n - The background layers;\n    + \"World\"\n    + \"Europe\"\n    \nA lot more than you might think for one map, don't stress, not all maps have this many layers... some have more! Thankfully, most of our data comes wrapped up within the tmap package already, so we don't have to do any work to find those. However, we will have to find our own source for the \"Europe\" background layer. There are plenty of options online, but if I'm honest I can't even remember which one I used. Anyway, lets bring all these datasets into a global environment.\n\n:::{.callout-note}\nFun side note, a lot of R packages are loaded in with their own testing datasets you can muck around with, such as tmap with its Netherlands dataset. Even base R has its own datasets you can access right away!\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#get a visual on the district dataset (it is pre-loaded in tmap, but we can't see it in our global environment yet)\nnld_district <- NLD_dist\n\n#get the CRS of our main dataset, and use this to convert all others as needed\nproj_crs <- st_crs(nld_district)\n\n#get a visual on the municipality dataset\nnld_municipality <- NLD_muni |> \n  st_transform(proj_crs)\n\n#get a visual on the province dataset\nnld_province <- NLD_prov |> \n  st_transform(proj_crs)\n\n#load in the Europe background data\neurope_background <- read_sf(\"Europe_coastline_poly.shp\") |> \n  st_transform(proj_crs)\n\n#get a visual on the world dataset\nworld_background <- World |> \n  st_transform(proj_crs)\n```\n:::\n\n\n\nAt this point it is usually a great idea to map each layer individually to start to get an idea of what you are working with.\n\n## Edit the Datasets\n\nThe day that I don't have to conduct edits on my data before mapping is the same day that I win the lottery. Editing the data is another step that is often overlooked in the process of making maps, usually because in demonstrations the edits and changes have been made before hand. That will not be the case here, I will be working step by step through each of the changes I made to the raw data to ensure that I got the best visualisation possible.\n\nFirst up is the Europe background layer. The first issue I have with this dataset is to do with its resolution compared to the Netherlands dataset. For example, here is each layer:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(europe_background) + \n  tm_polygons(fill = \"#00252A\",\n              col = \"#00252A\") +\n  tm_shape(nld_district, is.main = T) + \n  tm_polygons(fill = \"#e6aa04\", \n              col = \"#e6aa04\") +\n  tm_add_legend(fill = c(\"#00252A\", \"#e6aa04\"),\n                labels = c(\"Europe\", \"Netherlands\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nWe are going to assume that the border for the Netherlands dataset is indeed more accurate and precise than the Europe dataset (given the scale). Therefore, looking at these two layers we can see that there should be a gap in the Europe dataset in the upper middle portion of the Netherlands that corresponds to a shallow bay. However the Europe dataset seems to be too low resolution to pick this up, so we will have to do it ourselves. This is achieved fairly easily:\n\n - Convert the Netherlands dataset into one big polygon (remove any interior detailing)\n - Use this to cut a hole out of the Europe dataset.\n - The Europe dataset will no longer appear in the shallow bay.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a single polygon of the district dataset\nnld_dist_tmp <- st_union(nld_district)\n\n#remove any holes within the polygon then make the shape valid\nnld_dist_tmp <- st_remove_holes(nld_dist_tmp) |> \n  st_make_valid()\n                      \n#take the Europe background and cut a hole out of it using the dataset above\neurope_sans_nld <- st_difference(europe_background, nld_dist_tmp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#the first map is before any changes\nmap1 <- tm_shape(europe_background) +\n  tm_polygons(fill = \"#00252A\",\n              col = \"#00252A\") +\n   tm_shape(nld_district, is.main = T) + \n  tm_polygons(fill = \"#e6aa04\", \n              col = \"#e6aa04\")\n\n#The netherlands dataset as a single polygon\nmap2 <- tm_shape(nld_dist_tmp) +\n  tm_polygons(fill = \"#e6aa04\", \n              col = \"#e6aa04\")\n\n#after cutting out a section of the data\nmap3 <- tm_shape(europe_sans_nld) +\n  tm_polygons(fill = \"#00252A\",\n              col = \"#00252A\") +\n  tm_shape(nld_dist_tmp, is.main = T) +\n  tm_polygons(fill = NULL,\n              col = NULL)\n\n#how the finished product looks\nmap4 <- tm_shape(europe_sans_nld) + \n  tm_polygons(fill = \"#00252A\",\n              col = \"#00252A\") +\n  tm_shape(nld_district, is.main = T) + \n  tm_polygons(fill = \"#e6aa04\", \n              col = \"#e6aa04\")\n\n#arrange the maps into a row of 4\ntmap_arrange(map1, map2, map3, map4, nrow = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nNot perfect, but definitely better as we can now clearly tell that area is supposed to be a shallow bay.\n\nThe second issue I have with the Europe dataset is that it is too big, and it takes quite a while to create each map - which is frustrating. To fix this we are going to crop the outer area of the dataset, because we aren't interested in that part and won't actually be showing it on our map. This is also achieved fairly easily:\n\n - Convert the Netherlands dataset into one big bounding box (I.e., the most N,E,S,W points of the dataset)\n - Expand the bounding box until it is just large than the map we intent to create\n - Use this to crop the Europe dataset.\n - The Europe dataset will no longer contain all of Europe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#buffer (make bigger) the temporary dataset\nnld_dist_buf <- st_buffer(nld_dist_tmp, 30000) #units is meters for this dataset (it can change)\n\n#convert the temporary dataset to a bounding box object, then back to an sf object (must be sf for mapping)\nnld_dist_bb <- st_as_sfc(st_bbox(nld_dist_buf))\n\n#crop the europe background dataset\neurope_final <- st_intersection(europe_sans_nld, nld_dist_bb)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#the first map is the buffered Netherlands dataset with a bbox over the top\nmap1 <- tm_shape(nld_district) + \n  tm_polygons(fill = \"#e6aa04\", \n              col = \"#e6aa04\") +\n  tm_shape(nld_dist_buf) +\n  tm_polygons(fill = NULL, \n              col = \"#8E3B46\") +\n  tm_shape(nld_dist_bb, is.main = T) +\n  tm_polygons(fill = NULL,\n              col = \"#8E3B46\")\n\n#then Europe before changes with the bbox shown\nmap2 <- tm_shape(europe_sans_nld) +\n  tm_polygons(fill = \"#00252A\",\n              col = \"#00252A\") +\n  tm_shape(nld_dist_bb) +\n  tm_polygons(fill = NULL,\n              col = \"#8E3B46\") +\n  tm_shape(frame_position, is.main = T) + #this is just to position the frame, dw about it\n  tm_polygons(fill = NULL,\n              col = NULL)\n\n#after cropping the data\nmap3 <- tm_shape(europe_final) +\n  tm_polygons(fill = \"#00252A\",\n              col = \"#00252A\") +\n  tm_shape(frame_position, is.main = T) + #this is just to position the frame, dw about it\n  tm_polygons(fill = NULL,\n              col = NULL)\n\n#arrange the maps into a row of 4\ntmap_arrange(map1, map2, map3, nrow = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nA subtle change, but one which leads to much faster processing and therefore greater efficiency.\n\nThe Europe dataset has now received all of its edits, but we are not done yet. Next up is the \"world\" dataset. The problem I have with this dataset is ironically that the data is stored **too** efficiently! What I mean by this is that the data is stored in multipolygons, not [single]polygons. For example, a single polygon dataset would have rows of data like this:\n\n|Country     |Code  |geom         |\n|------------|------|-------------|\n|France      |FRA   |polygon(...) |\n|France      |FRA   |polygon(...) |\n|France      |FRA   |polygon(...) |\n|Germany     |DEU   |polygon(...) |\n|Germany     |DEU   |polygon(...) |\n|Germany     |DEU   |polygon(...) |\n|and so on...|...   |...          |\n\n(There are only multiple rows if there are multiple seperate landmasses belonging to the country).\n\nWhere as a single multipolygon dataset would have rows of data like this:\n\n|Country     |Code  |geom         |\n|------------|------|-------------|\n|France      |FRA   |multipolygon(polygon(...), polygon(...), polygon(...) |\n|Germany     |DEU   |multipolygon(polygon(...), polygon(...), polygon(...) |\n|and so on...|...   |...          |\n\nIf a row shares all the same metadata, then the geometry information is combined into a single multipolygon. Normally this is fine, but what I want to do with this dataset is put country labels on the surrounding countries so that the reader can be better orientated if they are not overly familiar with Europe. The issue is the labels are essentially applied \"per row\", and are put at the exact center of that rows' geometry. Which in some cases for multipolygons...:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract france from the world dataset\nfrance_example <- world_background |> \n  filter(name == \"France\")\n\n#create the example map\ntm_shape(world_background) +\n  tm_polygons(fill = \"#99B5B1\",\n              col = \"#7bba9d\") +\n  tm_layout(bg.color = \"#C1DEEA\") +\n  tm_shape(france_example, is.main = T) +\n  tm_polygons(fill = \"name\",\n              fill.scale = tm_scale_categorical(values = c(\"#e6aa04\", \"#8E3B46\", \"#00252A\"))) +\n  tm_text(text = \"name\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nis in the middle of the ocean!\n\nOnce again, this is a relatively easy fix. All we need to do is convert from a dataset that stores its geometry information as multipolygons, to a dataset that stores the information as just polygons:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract rows into single polygons for our example\nfrance_example <- world_background |> \n  filter(name == \"France\") |> \n  st_cast(\"POLYGON\") |> \n  mutate(Id = row_number())\n\n#then do it for real on the dataset we will actually be using \nworld_final <- world_background |> \n  st_cast(\"POLYGON\") |> \n  mutate(Id = row_number())\n\n#create the example map\ntm_shape(world_background) +\n  tm_polygons(fill = \"#99B5B1\",\n              col = \"#7bba9d\") +\n  tm_layout(bg.color = \"#C1DEEA\") +\n  tm_shape(france_example, is.main = T) +\n  tm_polygons(fill = \"Id\",\n              fill.scale = tm_scale_categorical(values = c(\"#e6aa04\", \"#8E3B46\", \"#00252A\"),\n                                                labels = c(\"Polygon 1\", \"Polygon 2\", \"Polygon 3\")),\n              fill.legend = tm_legend(title = \"France Polygons\")) +\n  tm_text(text = \"name\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nAwesome! And that now concludes the major data edits that we needed to conduct before starting the mapping (nearly there I promise).\n\n:::{.callout-note}\nSide note, before I create each map I do a few more minor data edits. But these don't really need explaining and are better suited sitting with the mapping code.\n:::\n\n## Create the Inset Map\n\nThe final stage to address before we get to the real juicy part, is asking the question \"would this map benefit from a secondary/inset map?\" Sometimes this inset map is a more zoomed in version of the main map that gives a closer look at a particular part of the area, or sometimes it is a more zoomed out version that provided context about where the main map in located in a wider region. In either case, consider if your map would be better if it had it. For the purposes of this demonstration I will of course be saying that my map needs an inset map, whether you agree or not is up to you.\n\nIn the case of creating an inset map that is more zoomed in, I would recommend doing that after the main map. However, when creating an inset map that is more zoomed out - I usually try to do that first. So off we go, its pretty easy, there are often only 2 or 3 components to my inset maps:\n\n 1. The background. Sometimes I can get away with recycling one of the main datasets, but for this map I had to get a whole new dataset. This background is the \"world\" dataset that we were editing above.\n 2. The reference box. I create a bounding box that extends the perimeter of my main map, then I use this bounding box as a layer in the inset map. This bounding box tells the reader exactly where the main map is located.\n 3. In some cases it might be helpful to have another bounding box if there are a few key areas. For us, we don't need that today.\n \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a bounding box for the extent of our main layer and/or focus area (remember we have to covert this back to an sf object for mapping purposes)\nnld_bbox <- st_as_sfc(st_bbox(nld_district))\n\n#create a larger bounding box of the main layer to use to set the perspective (play around with the distance to get what suits you)\ninset_view_positioning <- nld_municipality |> \n  st_buffer(dist = 1000000) |> #create a much larger buffer around our main layer\n  st_bbox() |> #turn the data into a bounding box\n  st_as_sfc() #turn the bounding box into an sf object (required for mapping)\n\n#create the inset map\ninset_map <- tm_shape(inset_view_positioning) + #this positions our perspective\n  tm_polygons(fill = NULL, #make both null so we don't actually see anything\n              col = NULL) + \n  tm_shape(world_final) + #this is the full background\n  tm_polygons(fill =  \"#99B5B1\") + #a muted green colour (land)\n  tm_text(text = \"iso_a3\", #each country gets its named printed \n          size = 0.3, #not too big\n          options = opt_tm_text(shadow = T, #with a shadow on the text to make it pop\n                                shadow.offset.x = 0.01,\n                                shadow.offset.y = 0.01)) + \n  tm_shape(nld_bbox) + #this is the bounding box of our main layer\n  tm_borders(lwd = 2, #we could also have used tm_polygons, but lets try something new\n             col = \"#8E3B46\") + #a deep red colour\n  tm_layout(asp = 0, #set aspect to zero to make the map full fill the frame when printed\n            bg.color = \"#C1DEEA\", # mute blue colour (ocean)\n            outer.bg.color = \"#F2F2F2\") # a very subtle eggshell (the background of my website)\n```\n:::\n\n\n\nDon't worry if this seems like a lot, once you start creating your own maps you will find it all makes sense :) Lets take a quick peak at the map now as well:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninset_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## Create the Main Map\n\nOkay nerds, the part you've all been waiting for, the main map. This map has a few layers to it:\n\n 1. The background, we are using the Europe background for this map (not the world background) as the Europe dataset has much greater detail which is necessary for viewing up close. Remember that we have also already edited the Europe dataset to have the better borders around the Netherlands as well. \n 2. The Netherlands district data, the focus of our map is population count per province. This is where a lot of the detail is going to come from so we have picked the dataset with the smallest cells.\n 3. The Netherlands municipality data, which we just use for the larger borders.\n 4. The Netherlands province data. We are also using this for its borders (larger again), but just to add a pop of red into the map as that is my colour scheme.\n \nAnd that's it, the rest of the detail comes just from the code:\n \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#add a value of 1 to every row of population data (because you cant log transform zero)\nnld_district <- nld_district |> \n  mutate(population = population+1)\n\n#edit the province dataset to have a column named \"province' (a trick to streamline the legend)\nnld_province <- nld_province |> \n  mutate(UseMe = \"Province\")\n\n#edit the municipality dataset to have a column named \"municipality\" (same trick)\nnld_municipality <- nld_municipality |> \n  mutate(UseMe = \"Municipality\")\n\n#create the map\nmain_map <- tm_shape(europe_final) + #the background data\n  tm_polygons(fill = \"#99B5B1\", #a muted green (land)\n              col = \"#7bba9d\") + #a slightly darker green for the borders\n  tm_shape(nld_district, is.main = T) + #the main dataset (use \"is.main\" to make sure the perspective is set by this layer)\n  tm_polygons(fill = \"population\", #what column dictates the styling\n              fill.scale = tm_scale_continuous_log(values = c(\"#FFFFFF\", \"#00252A\"), #white to a dark green\n                                                   ticks = c(1, 10000, 100000)), #what ticks are visible in the legend\n              fill.legend = tm_legend(title = \"Population\", #what is the title of the legend\n                                      position = tm_pos_out(\"right\", \"center\"), #where is the legend positioned\n                                      title.color = \"black\", #what is the colour of the legend title\n                                      reverse = TRUE), #reverse the numbers (1 at the bottom) of the legend\n              col = NULL) + #make sure the borders between districts are not visible\n  tm_shape(nld_municipality) + #municipality borders\n  tm_borders(col = \"UseMe\", #what column dictates the styling - this will also determine the name for this legend\n             col.scale = tm_scale_categorical(values = \"#e6aa04\"), #bright orange\n             col.legend = tm_legend(title = \"\", #no title (the name is in the key instead)\n                                    position = tm_pos_out(\"right\", \"center\"), #legend positioning\n                                    lwd = 2), #how thick is the line in the legend\n             lwd = 1) + #how thick is the line on the map\n  tm_shape(nld_province) + #province borders\n  tm_borders(col = \"UseMe\", #what column dictates the styling - this will also determine the name for this legend\n             col.scale = tm_scale_categorical(values = \"#8E3B46\"), #a dark red\n             col.legend = tm_legend(title = \"\",  #no title (the name is in the key instead)\n                                    position = tm_pos_out(\"right\", \"center\")), #legend positioning\n             lwd = 2) + #how thick is the line on the map\n  tm_layout(bg.color = \"#C1DEEA\", #a muted blue (ocean)\n            legend.bg.color = \"white\", #background colour of the legend\n            asp = 0, #set aspect to zero to make the map full fill the frame when printed\n            outer.bg.color = \"#F2F2F2\") + # a very subtle eggshell (the background of my website)\n  tm_credits(\"Â© Data: Statistics Netherlands, Software: R-tmap\\n Map Created: Adam Shand\", #some credit text to add to the map\n             position = c(\"left\", \"bottom\")) + #where does the text go\n  tm_compass(type = \"rose\", #what type of compass\n             position = c(\"LEFT\", \"TOP\"), #where is the compass positioned\n             color.dark = \"black\", #what is the \"dark\" colour of the compass\n             color.light = \"white\", #what is the \"light\" colour of the compass\n             size = 3.5) #how big is the compass\n```\n:::\n\n\n\nOnce again this might seem like a lot, but I promise it really isn't that bad once you get the hang of it. Plus, the control you will have over the styling of your maps is amazing. Anyway, here's how the main map looks:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmain_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Create The Final Map\n\nThe final stage of making our map is to combine the inset map and the main map. To achieve this we need to create a \"viewport\" using the `grid` package, which is essentially a little box somewhere on the main map that we can put the inset map inside. Getting the correct positioning of the viewport can be a bit tricky as the controls are not completely intuitive, so I will give a little demonstration of how things work. \n\nThe viewport is created with the function `viewport`, which has a few main arguments; `viewport(x, y, width, height, just)`. Each of these control the follow aspects:\n\n - x = the position of the viewport on the x-axis as a proportion (scaled from 0 to 1)\n - y = the position of the viewport on the y-axis as a proportion (scaled from 0 to 1)\n - width = the width of the viewport window as a proportion of the whole image.\n - height = the height of the viewport window as a proportion of the whole image.\n - just = the \"starting\" point of the positioning. This is where things become less intuitive.\n \nWidth and height are pretty obvious so we will skip over those. However, x, y, and just all interact with one other. For example, if we set x and y to 0.3 , and just to \"right\"/\"bottom\" we get the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a viewport using the viewport function\nexample_viewport <- viewport(y = 0.3,\n                             x = 0.3, \n                             width = 0.2,\n                             height = 0.2, \n                             just = c(\"right\", \"bottom\")) \n\n#place the viewport\ntmap_save(main_map, \n          \"example_viewport1.png\", \n          insets_tm = inset_map, \n          insets_vp = example_viewport, \n          height = 6, \n          width = 8)\n```\n:::\n\n\n\n![Example Viewport 1](example_viewport1.png)\n\nBut if we, change just to \"left\"/\"bottom\" we get the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a viewport using the viewport function\nexample_viewport <- viewport(y = 0.3,\n                             x = 0.3, \n                             width = 0.2,\n                             height = 0.2, \n                             just = c(\"left\", \"bottom\")) \n\n#place the viewport\ntmap_save(main_map, \n          \"example_viewport2.png\", \n          insets_tm = inset_map, \n          insets_vp = example_viewport, \n          height = 6, \n          width = 8)\n```\n:::\n\n\n\n![Example Viewport 2](example_viewport2.png)\n\nFurther again, lets change just to \"left\"/\"top\" we get the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a viewport using the viewport function\nexample_viewport <- viewport(y = 0.3,\n                             x = 0.3, \n                             width = 0.2,\n                             height = 0.2, \n                             just = c(\"left\", \"top\")) \n\n#place the viewport\ntmap_save(main_map, \n          \"example_viewport3.png\", \n          insets_tm = inset_map, \n          insets_vp = example_viewport, \n          height = 6, \n          width = 8)\n```\n:::\n\n\n\n![Example Viewport 3](example_viewport3.png)\n\nOkay, so what the hell is happening here? I have made this graphic to help explain:\n\n![Example Viewport 4](example_viewport4.png)\n\nSo essentially the \"just\" argument is telling the x and y arguments where to measure to on the viewport. If you try to make a viewport and it doesn't appear on your final map, the chances are that the interaction between x/y and just is putting the viewport window off the edge of the image. My positioning for the viewport is as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#place the viewport\ninset_viewport <- viewport(y = 0.015, #just a tiny bit off the bottom\n                           x = 0.98, #almost all the way over to the right\n                           width = 0.33, #make window 1/3 the size of the main image\n                           height = 0.33, #make window 1/3 the size of the main image\n                           just = c(\"right\", \"bottom\")) #x and y are to the right bottom of the window\n\n#save map\ntmap_save(main_map, \"final_map.png\", \n          insets_tm = inset_map, \n          insets_vp = inset_viewport,\n          height = 6, \n          width = 8)\n```\n:::\n\n\n\nHere's how that looks:\n\n![Final Image](final_map.png)\n\n# Caveats\n\nCreating beautiful maps takes time, no matter which program you use. The completed map I have been using in this demonstration took me several hours at least, and I'm already familiar with the method. Be persistent and stick with it. Good luck!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}