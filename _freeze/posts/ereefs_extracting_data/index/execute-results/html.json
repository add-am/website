{
  "hash": "97f16c1514c6db7c81bb6507c39b893e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Extraction of Highly Specialised Modeled Data from eReefs\"\ndate: \"05/23/2025\"\nabstract-title: \"ABSTRACT\"\nabstract: 'In this blog I talk about the skills needed and the steps taken to execute the extraction of modelled environmental data such as ocean currents, nutrient loads, and water clarity from the online platform \"eReefs\".'\nimage: \"image.png\"\nformat: html\ntitle-block-banner: true #This is our banner\ninclude-after-body: \"../../html/html_footer.html\" #This is our footer\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Introduction\n\nIn this blog post I'd like to cover the essentials of extracting data from the eReefs platform. First of all, hands up - who's heard of [eReefs](https://www.ereefs.org.au/)? Fair enough if you haven't, despite its star power in my world it is still a relatively niche topic. To summarise, eReefs is *\"a comprehensive view of dynamic marine environment conditions across the Great Barrier Reef from end-of-catchments and estuaries to reef lagoons and the open ocean.\"* What this means for us is that it has a whole bunch of modelled environmental datasets that are relatively easy to access, backed by top-notch science, and **heavy** (i.e. we really get to flex our coding and spatial \"muscles\"). \n\nThe goal today is to learn how to:\n\n 1. Extract data from eReefs - a surprisingly hard thing to do\n 2. That's it - the data extraction section is already going to make this a long post.\n \n:::{.callout-note}\nIf you read this blog and want to learn what to do once you have the data, make sure to check out these two additional blogs that explore [plotting](ereefs_plotting_data/index.qmd) and [mapping](ereefs_mapping_data/index.qmd) eReefs data.\n:::\n\n# Extracting Data\n\nThe datasets we are going to look at today are the chlorophyll a dataset, and the nitrites dataset. However there are hundreds of datasets to choose from including water movement variables, water clarity indicators, and a whole host of chemical indicators. Later in this blog I will show you how to obtain a complete list of variables available. \n\nAll data produced by eReefs is stored on the [National Computing Infrastructure's (NCIs) THREDDS server](https://thredds.nci.org.au/thredds/catalog/catalogs/fx3/catalog.html) which is a server we can interact with in an automated fashion. Don't be fooled though, accessing the data can still pose quite the challenge and can sometimes seem like you are feeling your way around in the dark.\n\nTo assist in the process of extracting data from eReefs we are going to need an extra dataset that details the specific boundaries of a target region within the scope of the eReefs model. I will be using the boundaries of the Dry Tropics region (near Townsville, QLD), however any boundaries withing the Great Barrier Reef Marine Park will work fine.\n\nLets get into it.\n\n## Step 1 - Obtain Facilitating Dataset\n\nThis is just about the only simple step in this blog. \n\nBelow I load in my boundaries of the Dry Tropics region, unfortunately this is a custom dataset that cannot be made available for download, however any polygon area within the Great Barrier Reef region will work so I encourage you to create your own.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#read in the dry tropics region dataset\ndt_region <- st_read(\"dt_region.gpkg\") |> \n  st_transform(\"EPSG:7844\")\n\n#create a perspective object, note this will use a different CRS as that is what is required further down\ndt_perspective <- st_buffer(dt_region, 0.5) |> \n  st_transform(\"EPSG:7855\")\n```\n:::\n\n\n\n:::{.callout-note}\nIn a pinch for coordinates? Use these for a simple box: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n\nexample_box <- matrix(c(144.227, -24.445,   # bottom-left\n                        144.227, -15.195,   # top-left\n                        151.329, -15.195,   # top-right\n                        151.329, -24.445,   # bottom-right\n                        144.227, -24.445),    # close the polygon by repeating the first point\n                      ncol = 2, \n                      byrow = TRUE)\n\n#create a polygon geometry and set the CRS\nexample_box <- st_polygon(list(example_box)) |> \n  st_sfc(crs = \"EPSG:7844\")\n```\n:::\n\n\n:::\n\n\n## Step 2 - Getting eReefs Data\n\nI would first like to note that there are several resources online that contain useful information about access data from eReefs. These include:\n\n - [An eReefs R Package](https://github.com/open-AIMS/ereefs)\n - [Multiple eReefs Tutorials](https://open-aims.github.io/ereefs-tutorials/)\n - [And, the National Computing Infrastructure's (NCIs) THREDDS server](https://thredds.nci.org.au/thredds/catalog/catalogs/fx3/catalog.html)\n \nHowever, I personally find that most of these resources either A) gloss over what is really happening behind the scenes, or B) don't provide critical information needed for you to go away and conduct your own analysis (for example, how to see what indicators are available in eReefs). It is these reasons among others that prompted me to write this blog.\n\nAnyway, time to buckle your seatbelts kids.\n\n### Connecting to the Data\n\nThe first thing we are going to do today is establish a connection to the database. To do this we are going to need to load the `ereefs()` package as this contains the handy functions `substitute_filename(\"catalog\")` and `get_ereefs_grids()`. First, we will run the `substitute_filename(\"catalog\")` function, which will return a list of all the available datasets that we can choose from. This list is interactive and requires user input - I have picked \"5\" - \"eReefs GBR1 biogeochemistry and sediments v3.2\" as this is the most up-to-date model. However, there are older models and models that have been run under different scenarios if you are interested in those instead.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load in the ereefs package\nlibrary(ereefs)\n\n#run the function\nsubstitute_filename(\"catalog\")\n```\n:::\n\n\n\nOnce we have made our selection it will return a url. This url is how we are going to connected to the correct database, if you are interested, [this](https://thredds.nci.org.au/thredds/catalog/catalogs/fx3/catalog.html) is a manual view of the range of data that we are choosing from.\n\nWe can these use this url as an argument in the `get_ereefs_grids()` function from the `ereefs` package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#manually assign the url from above into a variable (so I don't have to interact with the code)\ninput_file <- \"https://dapds00.nci.org.au/thredds/dodsC/fx3/GBR1_H2p0_B3p2_Cfur_Dnrt.ncml\"\n    \n#get all grids\ngrids <- get_ereefs_grids(input_file)\n```\n:::\n\n\n\n### Gaining Perspective\n\nIf the lines of code above worked, congratulations - you can access the data. Now take a look at the object `grids` and you will probably realise that we are only 3 lines of code in and things are already pretty intense - WTF is this object and what does it tell us? \n\nWhat we just did is get the dimensions of the dataset. The `grids` object should be a list of length 3, the 3 items in the list should be \"x_grid\", \"y_grid\", and \"z_grid\", each of the these tell us something about one dimension of the data (the longitude, latitude, and depth). Unfortunately, because each of these items are bloody huge manually viewing the object to try and learn about it is essentially useless. Below we use some simple code to explore the grids.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract just the x grid\nx_grid <- grids[[\"x_grid\"]]\n\n#get some basic information about the dataset\nxmin <- min(x_grid, na.rm = T)\nxmax <- max(x_grid, na.rm = T)\nx_dim <- dim(x_grid)\n```\n:::\n\n\n\nThe x_grid tells us about longitude The min x value is 142.018379, the max x value is 155.379686, and the dimensions of the x_grid are 511, 2390.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract just the y grid\ny_grid <- grids[[\"y_grid\"]]\n\n#get some basic information about the dataset\nymin <- min(y_grid, na.rm = T)\nymax <- max(y_grid, na.rm = T)\ny_dim <- dim(y_grid)\n```\n:::\n\n\n\nThe y_grid tells us about latitude. The min y value is -28.600577, the max x value is -7.386315, and the dimensions of the y_grid are 511, 2390. \n\nBy looking at the x and y values we can get an idea of where we are in the world:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(head(grids[[\"y_grid\"]], n = c(5,5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         V1        V2        V3        V4        V5\n1 -28.59505 -28.57945 -28.56385 -28.54808 -28.53231\n2 -28.59506 -28.57942 -28.56378 -28.54800 -28.53222\n3 -28.59508 -28.57940 -28.56371 -28.54792 -28.53214\n4 -28.59510 -28.57938 -28.56367 -28.54787 -28.53206\n5 -28.59511 -28.57937 -28.56362 -28.54781 -28.53199\n```\n\n\n:::\n\n```{.r .cell-code}\n#create a bbox\nereefs_extent_bbox <- matrix(c(xmin, ymin,   # bottom-left\n                               xmin, ymax,   # top-left\n                               xmax, ymax,   # top-right\n                               xmax, ymin,   # bottom-right\n                               xmin, ymin),    # close the polygon by repeating the first point\n                      ncol = 2, \n                      byrow = TRUE)\n\n#create a polygon geometry and set the CRS\nereefs_extent_bbox <- st_polygon(list(ereefs_extent_bbox)) |> \n  st_sfc(crs = \"EPSG:7844\")\n\ntm_shape(World) +\n  tm_polygons() +\n  tm_shape(ereefs_extent_bbox) +\n  tm_polygons(col = \"red\",\n              fill = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract just the x grid\nz_grid <- grids[[\"z_grid\"]]\n\n#get some basic information about the dataset\nz_min <- min(grids[[\"z_grid\"]], na.rm = T)\nz_max <- 0 #using max returns the \"wrong\" value for our discussion\nz_dim <- dim(grids[[\"z_grid\"]])\n```\n:::\n\n\n\nThe z_grid tells us about depth (eReefs models the entire water column). The min z value is -4000m, the max x value is 0m, and the dimensions of the z_grid are 45. These values tell us at what depth each layer of the model is at, and how many layers there are.\n\nIn combination these three grids tell us everything we need to know about the data. Lets first look at the x_grid, as we noted above, the dimensions of the x_grid are 511, 2390, thus picture a table that has 511 rows, and 2390 columns. Once again, here is a snapshot of the first five rows and columns of the grid: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(head(x_grid, n = c(5,5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        V1       V2       V3       V4       V5\n1 151.8048 151.8046 151.8044 151.8042 151.8039\n2 151.8140 151.8138 151.8137 151.8134 151.8132\n3 151.8231 151.8230 151.8229 151.8227 151.8226\n4 151.8324 151.8323 151.8322 151.8321 151.8319\n5 151.8416 151.8416 151.8415 151.8414 151.8413\n```\n\n\n:::\n:::\n\n\n\nIn contrast, lets now consider the y_grid, this grid has the exact same dimensions as the x_grid, and we can picture it much the same way: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(head(y_grid, n = c(5,5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         V1        V2        V3        V4        V5\n1 -28.59505 -28.57945 -28.56385 -28.54808 -28.53231\n2 -28.59506 -28.57942 -28.56378 -28.54800 -28.53222\n3 -28.59508 -28.57940 -28.56371 -28.54792 -28.53214\n4 -28.59510 -28.57938 -28.56367 -28.54787 -28.53206\n5 -28.59511 -28.57937 -28.56362 -28.54781 -28.53199\n```\n\n\n:::\n:::\n\n\n\nIf we combine these two grids together we can get a table in which every cell contains a pair of values, one x_grid value and one y_grid value:\n\n|   |1                        |2                        |3                        |4                        |5                        |\n|---|-------------------------|-------------------------|-------------------------|-------------------------|-------------------------|\n|1  |151.8048, -28.59505      |151.8046, -28.57945      |151.8044, -28.56385      |151.8042, -28.54808      |151.8039, -28.53231      |\n|2  |151.8140, -28.59506      |151.8138, -28.57942      |151.8137, -28.56378      |151.8134, -28.54800      |151.8132, -28.53222      |\n|3  |151.8231, -28.59508      |151.8230, -28.57940      |151.8229, -28.56371      |151.8227, -28.54792      |151.8226, -28.53214      |\n|4  |151.8324, -28.59510      |151.8323, -28.57938      |151.8322, -28.56367      |151.8321, -28.54787      |151.8319, -28.53206      |\n|5  |151.8416, -28.59511      |151.8416, -28.57937      |151.8415, -28.56362      |151.8414, -28.54781      |151.8413, -28.53199      |\n\n\nWhat we have now is a table where every single cell corresponds to a cell (value) in the eReefs model. That is to say, that for every cell in this table we just made, there is information about water temperature, turbidity, nutrients, etc., etc. To take things even further, if we include the z dimension depth we would have 45 copies of this table, with each copy of the table corresponding to 1 depth layer in the model.\n\nAdd that all up and we have a table that has 1221290 cells, where the table is stacked 45 times in a row (depth), where every cell in every table has more than 200 different environmental variables. Hopefully that makes sense.\n\nOK so sure, that's kind of cool I suppose, but why does this matter? Who cares?\n\nWell, the reason this matters is that we can use this conceptual understanding of the model to be able to sift through all that data to pinpoint the exact thing that we want. You could use this almost like a GPS. For example, If I wanted to figure out the water temperature at 151.4, -23.2, at a depth of -40m, all I would need to do is say \"give me the information at row 2, column 4\". \n\n### Specify Our Target Location\n\nTo explain how we are going to specify our target I am going to keep the analogy of the table going. The idea is simple, lets once again imagine the table, the table is the exact same dimensions as the table we were talking about above, except the values in this table are all just \"FALSE\":\n\n| |1    |2    |3    |4    |5    |\n|-|-----|-----|-----|-----|-----|\n|1|FALSE|FALSE|FALSE|FALSE|FALSE|\n|2|FALSE|FALSE|FALSE|FALSE|FALSE|\n|3|FALSE|FALSE|FALSE|FALSE|FALSE|\n|4|FALSE|FALSE|FALSE|FALSE|FALSE|\n|5|FALSE|FALSE|FALSE|FALSE|FALSE|\n\nLets say that we want to extract all the information within 151.2 to 151.4, and -23.3 to -23.5. What we then do is figure out where those cells are (based on their row and column number) using the table in the previous section, and then change the cells in those positions to TRUE in our current table:\n\n| |1    |2    |3    |4    |5    |\n|-|-----|-----|-----|-----|-----|\n|1|FALSE|FALSE|FALSE|FALSE|FALSE|\n|2|FALSE|FALSE|FALSE|FALSE|FALSE|\n|3|FALSE|TRUE |TRUE |TRUE |FALSE|\n|4|FALSE|TRUE |TRUE |TRUE |FALSE|\n|5|FALSE|TRUE |TRUE |TRUE |FALSE|\n\nWe can then use this table to communicate with the database and tell it \"only give me data that lines up with my true values, remove the rest\". And that's kind of it! If all goes well, the database will return the exact data you requested. Lets see how that looks in code.\n\n:::{.callout-note}\nIt is important to highlight here that the code we are about to write and the data we are working with does not take the form of an actual table, the above description is just a handy analogy to describe what is happening.\n:::\n\nThe first thing we are going to do is get the boundaries of our target area.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#use the bbox function to get the boundaries\ntarget_bounds <- st_bbox(dt_region)\n\ntarget_bounds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     xmin      ymin      xmax      ymax \n146.14439 -19.70039 148.29854 -17.62597 \n```\n\n\n:::\n:::\n\n\n\nThen we use a series of logical steps that check the xmin, xmax, ymin, and ymax values of our target area and changes cells that fall inside these bounds to TRUE (those outside are given FALSE). There are also some cells that start as NA, so we change those to FALSE.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#if the value is inside the bounds of each of our coords, change it to TRUE. Those outside are automatically false\ntrue_false_array <- x_grid >= target_bounds[1] & \n  x_grid <= target_bounds[3] & \n  y_grid >= target_bounds[2] & \n  y_grid <= target_bounds[4]\n  \n#if the value is NA, change it to false.\ntrue_false_array[is.na(true_false_array)] <- FALSE\n```\n:::\n\n\n\n### Obtain the \"Coordinates\" of Our Target Location\n\nSo what we did above was create an array that contains TRUE and FALSE values. The dimensions of this array perfectly match the dimensions of the data. Next up, we need to find the exact positions in the array where the values change from FALSE to TRUE (noting that TRUE means inside our area of interest). These positions will then correspond to the positions we need to send to the database. Here is the code to achieve this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#return the row index for every row that contains at least one true value:\ntrue_rows <- which(apply(true_false_array, 1, any))\n\n#find the first row that contains a true value\nfirst_row <- true_rows[1]\n\n#find the number of rows that contains a true value\nnum_of_rows <- tail(true_rows, n = 1) - first_row\n\n#return the row index for every row that contains at least one true value:\ntrue_cols <- which(apply(true_false_array, 2, any))\n\n#find the first col that contains a true value\nfirst_col <- true_cols[1]\n\n#find the number of cols that contains a true value\nnum_of_cols <- tail(true_cols, n = 1) - first_col\n```\n:::\n\n\n\nOur values are as follows:\n\n - First Row = 1\n - Number of Rows = 312\n - First Col = 1077\n - Number of Cols = 314\n \nWith that done we now have our \"coordinates\" to send to the database to tell it where to extract data from. \n\n### Specify Our Target Variable\n\nAlmost there, only one more part. In this section we are going to learn how to specify what variable to download. So far all I have told you is that eReefs has hundreds of variables, that's cool and all but what are their names? How do you access them? Thankfully the function `nc_vars()` from the `ncmeta` package can help us. Simply run the function for the input path we figured out earlier and it will return a table with all the variables available:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#return a table of all possible variables\nall_variables <- nc_vars(input_file)\n```\n:::\n\n\n\nBe careful though, the dimensions on some of these variables are different, and you might need to provide more (or less) information to make it work. For example, some variables might not have a depth (z) aspect to them and you would need to drop this from the data request.\n\nBy looking at this table we can establish that to get the chlorophyll a and the nitrites datasets we need to supply the names \"Chl_a_sum\" and \"NO3\".\n\n### Extract the Data\n\nIts finally time, after all that we can start our data extraction!\n\nThe function we are going to use to extract the data is the `read_ncdf()` function from the `stars` package. This function takes several inputs, such as the source of the data, the variable we are interested in, and the \"coordinates\" we are interested in. Thanks to all the work we have done above we have all of the \"hard\" information, however there are still a few little things to tick off.\n\nWhen we are talking about the \"coordinates\" of the data I have previously spoken about the x, y, and z dimensions of the data (the longitude, latitude, and depth). However there is one more dimension I haven't spoken about yet - time. Yes this data actually has 4 dimensions we need to specify. To keep things simple we will start off my just asking for a single point in time, but later we will move on to getting a full time series. So, when we supply the details we are essentially going to tell the database, \n\n - On the x dimension; start at this cell, and keep going until this cell\n - On the y dimension; start at this cell, and keep going until this cell\n - On the z dimension; just give us one depth layer\n - On the t dimension; just give us one time step\n\nIn code, this is how it looks:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#set our dimensions (44 is the surface depth, 100 is the 100th time step)\nour_dimensions_request <- cbind(start = c(first_row, first_col, 44, 100),\n                                count = c(num_of_rows, num_of_cols, 1, 1))\n```\n:::\n\n\n\nWhich we can supply to the `read_ncdf` function (it will take a little while to run, that's fine):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract the data\nextracted_data <- read_ncdf(input_file, \n                            var = \"Chl_a_sum\", \n                            ncsub = our_dimensions_request)\n```\n:::\n\n\n\nIf that code ran, congratulations you have official got the data.\n\n## Step 3 - View and Save eReefs Data\n\nWhat, there's still more to go? Unfortunately yes.\n\nLets immediately try and visualise the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#make a simple palette using our website colours\nmy_pal <- c(\"#A7C3C7\", \"#7EA0A7\", \"#55807D\", \"#2D6056\", \"#00402F\", \"#00252A\")\n\n#create a simple plot of the data\ntm_shape(extracted_data) +\n  tm_raster(col.scale = tm_scale_intervals(n = 6,\n                                           values = my_pal,\n                                           label.format = list(digits = 2)),\n            col.legend = tm_legend(reverse = T)) +\n  tm_shape(dt_region, is.main = T) +\n  tm_polygons(fill = NULL,\n              col = \"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nRather ugly yea? Also WTF is up with that scale? And why does the data extend past our area of interest?\n\n 1. Yes it is rather ugly, but it will mostly be fixed by 2.\n 2. The scale is because eReefs uses ridiculously high values for land cells (i.e. cells that shouldn't have a chlorophyll a value)\n 3. The data extends past our area of interest for a few reasons, we will fix this further below.\n \n\"Removing\" the land cells is rather easy, simply pick a value that your dataset would never reach (e.g. 1000ug/L) and change all cells with a value greater than that to NA. Visually, this fixes both points 1 and 2:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#change all land values to NA\nextracted_data[(extracted_data > 1000)] <- NA\n\n#create a simple plot of the data\ntm_shape(extracted_data) +\n  tm_raster(col.scale = tm_scale_intervals(n = 6,\n                                           values = my_pal,\n                                           label.format = list(digits = 2)),\n            col.legend = tm_legend(reverse = T)) +\n  tm_shape(dt_region) +\n  tm_polygons(fill = NULL,\n              col = \"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\nThat's already much better looking. However we still have the problem of data extending past our area of interest.\n\n### Cropping Data\n\nThe next step I'd like to explore is conducting an intial crop of our data, this is because as we noted above, the data extends outside our area of interest, despite our efforts when requestiong the data. This is for two main reasons: \n\n 1. Because when we request data we need to use the maximum bounds of our object, and\n 2. Because the data is on a curvilinear grid - which messes with the grid layout.\n \n#### Curvilinear Grid Data\n \n:::{.callout-note}\nRaster data can be provided in a range of different grid types. The most common, and the one you are probably familiar with is the regular grid. In this type of grid each cell is consistent. In a curvilinear grid, cells bend and twist to allow for a higher concentration of cells in area that require greater resolution. This has the benefit of reducing file size, but the downside of inflicting physic damage to the uninitiated spatial analyst.\n\nIf you would like to learn more about different grid types, check out [this](https://r-spatial.github.io/stars/articles/stars4.html) handy explainer.\n:::\n \nTo help us understand this, here is a map showing the bounding box in red that we used to request the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a simple plot of the data\ntm_shape(extracted_data) +\n  tm_raster(col.scale = tm_scale_intervals(n = 6,\n                                           values = my_pal,\n                                           label.format = list(digits = 2)),\n            col.legend = tm_legend(reverse = T)) +\n  tm_shape(dt_region) +\n  tm_polygons(fill = NULL,\n              col = \"black\") +\n  tm_shape(st_as_sfc(target_bounds)) +\n  tm_polygons(fill = NULL,\n              col = \"#E6AA04\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nwhich demonstrates how the top left and bottom right corners are defining the region in which data is collected - at least a little bit. In this map we can also start to see the effect of the curvilinear grid and how it twists the data. A closer look at the actual grid lines of the data might demonstrate this a bit clearer:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract each cell as a polygon\ncurvilinear_polygons <- st_as_sf(extracted_data, as_points = FALSE, merge = FALSE)\n\n#create a simple map\ntm_shape(curvilinear_polygons) +\n  tm_borders(col = \"#00252A\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nEspecially if you compare this to a linear grid representing the same area:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a simple map\ntm_shape(warped_data_sf) +\n  tm_borders(col = \"#00252A\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nSo what can we do with this new found knowledge? Well for one thing it gives us a better understanding of how the data is organised, for example if you run `extracted_data` you might now understand why offset is NA - because the offset changes per cell. But secondly, it is about to play an important role in cropping the data.\n\nWe can crop almost any stars object (curvilinear grid, or regular grid) using `st_crop()` and it will broadly do what we want:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#project our cropping dataset to a projected (meters) crs\ndt_region <- dt_region |> \n  st_transform(\"EPSG:7855\")\n\n#crop to the actual area of interest\ncropped_data_example_1 <- extracted_data |> \n  st_crop(dt_region)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a simple map\ntm_shape(cropped_data_example_1) +\n  tm_raster(col.scale = tm_scale_intervals(n = 6,\n                                           values = my_pal,\n                                           label.format = list(digits = 2)),\n            col.legend = tm_legend(reverse = T)) +\n  tm_shape(dt_region, is.main =  T) +\n  tm_polygons(fill = NULL,\n              col = \"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nHowever you may notice that the `st_crop()` function is providing a warning. like this:\n\n\"Warning in st_crop.stars(st_transform(extracted_data, \"EPSG:7844\"), dt_region) :\n  crop only crops regular grids: maybe use st_warp() first?\"\n  \nAdditionally, if you inspect the dimensions of the original data in comparison to the cropped data it is clear something funky is going on:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(extracted_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   i    j    k time \n 312  314    1    1 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(cropped_data_example_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   i    j    k time \n 312  314    1    1 \n```\n\n\n:::\n:::\n\n\n\nIndeed, if you inspect each of the objects again, using `extracted_data`, and `cropped_data_example_1` you can see that the only thing that really changed is that there are now more NA values. So what `st_crop()` actually did in this scenario was just replace values outside our area with NA:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a simple map\ntm_shape(cropped_data_example_1) +\n  tm_raster(col.scale = tm_scale_intervals(n = 6,\n                                           values = my_pal,\n                                           label.format = list(digits = 2),\n                                           value.na = \"#E6AA04\"),\n            col.legend = tm_legend(reverse = T)) +\n  tm_shape(dt_region) +\n  tm_polygons(fill = NULL,\n              col = \"black\") +\n  tm_shape(dt_perspective, is.main =  T) +\n  tm_polygons(fill = NULL,\n              col = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\nWhich is not necessarily a bad thing, but can become a big problem if we are particularly concerned about file size.\n\nThe reason this occurs is mostly a mystery to me, but I believe it has to do with the way the grid cells on a curvilinear raster are set out - and that those NA cells are needed to provide positioning context to the rest of the cells.\n\n#### Regular Grid Data\n\nThe solution to this is of course what was recommended in the original warning message - to use `st_warp()` to shift the data from a curvilinear grid onto a regular grid. This is thankfully not to difficult, and only has four main steps:\n\n 1. Obtain the xmin, xmax, ymin, and ymax bounds of our curvilinear object\n 2. Obtain the x and y dimensions of our curvilinear object (i.e. number of rows and cols)\n 3. Create a \"destination\" regular grid using the values determined in steps 1. and 2.\n 4. Warp the curvilinear object onto the destination grid, matching cell to cell.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#project our curvilinear data to a projected (meters) crs\nextracted_data <- extracted_data |> \n  st_transform(\"EPSG:7855\")\n\n#convert our curvilinear object into just a bbox then update the crs on the bbox\ncurvi_bbox <- extracted_data |> \n  st_bbox() |>\n  st_as_sfc()\n\n#get a linear grid target with the same dimensions (number of cells) as our curvilinear grid \nreg_stars <- st_as_stars(curvi_bbox, #using the bbox to provide the xmin, xmax etc., \n                         nx = dim(extracted_data)[[1]], #and the dimensions to provide the x and y count. \n                         ny = dim(extracted_data)[[2]], \n                         values = NA_real_) #Fill each cell with NA\n\n#run st warp, it requires a curvilinear object, and a regular object as a target\nwarped_data <- st_warp(extracted_data, reg_stars)\n```\n:::\n\n\n\nWith the warped data we can then use the `st_crop()` function again:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#crop to the actual area of interest\ncropped_data_example_2 <- warped_data |> \n  st_crop(dt_region)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#create a simple map\ntm_shape(cropped_data_example_2) +\n  tm_raster(col.scale = tm_scale_intervals(n = 6,\n                                           values = my_pal,\n                                           label.format = list(digits = 2),\n                                           value.na = \"#E6AA04\"),\n            col.legend = tm_legend(reverse = T)) +\n  tm_shape(dt_region, is.main =  T) +\n  tm_polygons(fill = NULL,\n              col = \"black\") +\n  tm_shape(dt_perspective, is.main = T) +\n  tm_polygons(fill = NULL,\n              col = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\nThus actually cropping the data to the bounding box of our target area, and create a map with significantly few NA cells, specifically the curviliear version has 74496 NA values, and the regular grid version has 17086 NA values - a difference of 57410\n\n\n\n\n\n\n\n## eReefs Data\n\nNow we can look to download the eReefs data. We will be using the spatial information for each of the regions that we loaded above to guide us when extracting the eReefs data.\n\n::: {.callout-note}\nPlease note that this script will download the eReefs data from an online server the first time the script is run. This is a lengthy process given the size of the data (several gb) and will take a significant amount of time to process (approximately 20 minutes). To assist in future runs of the script, the data will be saved to your local computer and reloaded next time (approximate 30 seconds).\n:::\n\nGiven that this is the 6th script in the series about eReefs data we already have a significant amount of contextual information about the data that makes it a lot easier to understand what data we are downloading and how we can access it. (Not all previous scripts have to be run, but reading them does help). \n\nUsing script 5 we know that to get the data for each year we need to access the following layers:\n\n- 2019-2020 = 1-215 (215 layers total)\n- 2020-2021 = 216-580 (365 layers total)\n- 2021-2022 = 581-945 (365 layers total)\n- 2022-2023 = 946-1310 (365 layers total)\n- 2023-2024 = 1311-1510 (200 layers)\n\nFor this script we can focus on downloading just the year of data that is closest to our target data year. I say closest because data is only released roughly every 2 years, thus sometimes the target year matches, sometimes it does not. The general method of downloading is as follows:\n\n1. Set up a table containing the layer counter information determined above and then identify the year we are interested in.\n2. Establish coordinate boundaries of the area of interest\n3. Extract grid cell latitude, longitude information within this area of interest\n4. Compare the coordinate boundaries of the area of interest with the grid cell latitude and longitude (this is because the grid cells are on a curvilinear grid and sometimes extend outside our area of interest due to the line \"bending\")\n5. From this comparison, extract the true start and end points of the area of interest, accounting for bending\n6. Download each financial year of data individually, using information from steps 4. and 5.\n\n:::{.callout-note}\nUse nc_vars(input_file) to get a table that lists all available variables. It will also tell you the dimensions needed to call the data (usually 3 or 4).\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#save(list = glue(\"{i_lower}_{region_lower}\"), \n#     file = glue('{output_path}/datasets/{i_lower}_{region_lower}.RData'))\n        \n  \n  #overwrite erroneous high values (note that a value of even 50 would be very very high)\n#  dataset[(dataset > 200)] <- NA\n  \n  #crop to the actual area of interest\n#  dataset <- dataset |> \n#   st_transform(proj_crs)# |>\n\n\n\n#map <- tm_shape(qld) +\n#    tm_polygons(fill = \"#99B5B1\",\n#                col = \"#7bba9d\") +\n#    tm_shape(target_land_region) +\n#    tm_polygons(fill = \"grey90\", \n#                col = \"black\") +\n#    tm_shape(monthly_mean_df[[i]]) +\n#    tm_polygons(fill = \"Value\",\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}