[
  {
    "objectID": "posts/loops_and_vectorised_functions/index.html",
    "href": "posts/loops_and_vectorised_functions/index.html",
    "title": "An Epic Battle Between For Loops and Vectorised Functions",
    "section": "",
    "text": "Main points to hit\n\nkey: this is the natural follow up from writing your own function AND from creating for loops\nthe comparison between for loops and vectorised functions, why should you try to move over to vectorised functions\n\nimproved run time (usually)\nhuman time (more important) - although sometimes I doubt readability\n\nhow did I learn to understand vectorised functions\nwhat is a compelling reason to try/learn"
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Environmental Bytes for a Better Earth",
    "section": "",
    "text": "Document\n\n\n  \n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n\n\n\n\n\n\n\n\n\n\nAn Opinionated Dataframe Cleaner\n\n\n\n\n\nNaming your dataframe columns doesn’t have to be hard, does it? Here I demonstrate the benefits of implimenting an opionated dataframe cleaner to help keep your columns organised.\n\n\n\n\n\n04 Jan, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGoing Loopy for For Loops\n\n\n\n\n\nTBD.\n\n\n\n\n\n04 Jan, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLearning To Create Your Own Custom Functions\n\n\n\n\n\nTBD.\n\n\n\n\n\n04 Jan, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nAn Epic Battle Between For Loops and Vectorised Functions\n\n\n\n\n\nTBD.\n\n\n\n\n\n04 Jan, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/an_opinionated_dataframe_cleaner/index.html",
    "href": "posts/an_opinionated_dataframe_cleaner/index.html",
    "title": "An Opinionated Dataframe Cleaner",
    "section": "",
    "text": "1 Introduction\nInconsistent and illogical naming conventions can ruin even the best analysts flow, cause sneaky errors, and potentially lead to misleading or completely incorrect results. Throughout my time as an environmental data analyst I have come across countless instances where the names used in a dataframe mess up my analysis, and I can guarantee I’m not the only one. Just Google “the importance of file naming” to find countless monologues (just like this one), or “bad naming conventions” to realize, actually it could be worse!\nSo if this is such a widely acknowledged issue, why is it still an issue? How has it not been fixed? Simply put, because a) its boring, and b) everyone is unique and has their own idea of what a “good” system looks like. This leads to people not bothering, or instances where you might pull together several datasets from a range of sources, each using their own (different) naming conventions. Thankfully, if each dataset is at least internally consistent, we can address these differences.\nBelow, I introduce my method of addressing this issue. It is a highly opinionated dataframe cleaner that focuses exclusively on ensuring every dataframe I touch receives exactly the same column naming convention. Before we dive into it, I believe it is critical to recognise that this method is customized to my needs, it may work for you as well, but I recommend instead that you use this as inspiration to develop your own method.\n\n\n2 The Naming Convention\nSo what naming convention am I using exactly? “Upper Camel Case” is my choice, however some people may also refer to it as “Pascal Case”. If your are unfamiliar, here are some examples of naming conventions:\n\nUpperCamelCase\nsnake_case\nkebab-case\nUPPERFLATCASE\netc.\n\nWhy UpperCamelCase? As noted above, everyone has their own idea of what is good. I find that upper camel case suite my purposes well, it is fairly easy to read, it only contains A-Z, 0-9 (no underscores or dashes), and most importantly it does not clash with my object names when coding it in R. What I mean by this is that I use snake_case to name my objects, and UpperCamelCase to name columns within my objects. Lets consider the following example.\nLets say I have a dataframe that counts fish (called “fish”):\n\n\nCode\n#load the dplyr package\nlibrary(dplyr)\n\n#create an example dataframe\nfish &lt;- data.frame(species = c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n                   fish_count_location_1 = c(6,9,3,5,10),\n                   fish_count_location_2 = c(1,16,3,2,7))\n\n#print the dataframe. If you want to learn about this function, check out my pretty tables post!\ncond_form_tables(fish)\n\n\n\n\nspeciesfish_count_location_1fish_count_location_2\n\nA61\n\nB916\n\nC33\n\nD52\n\nE107\n\n\n\n\n(Note that both the object and column names are in snake_case).\nThen I decide to figure out the mean number of each species of fish, across all locations (called “mean_fish”):\n\n\nCode\n#get the rowwise mean of the fish counts per species\nmean_fish &lt;- fish |&gt; \n  rowwise() |&gt; \n  mutate(mean_fish = mean(c(fish_count_location_1, fish_count_location_2))) |&gt; \n  ungroup()\n\n#print the dataframe\ncond_form_tables(mean_fish)\n\n\n\n\nspeciesfish_count_location_1fish_count_location_2mean_fish\n\nA613.5\n\nB91612.5\n\nC333  \n\nD523.5\n\nE1078.5\n\n\n\n\nWhoops, just by using some logical naming I now accidentally have a dataframe object named “mean_fish”, and a column within that dataframe named “mean_fish”. Now obviously this is a silly example, but imaging we have 1000+ lines of code, and we need to know something about the mean number of fish. Suddenly we can’t remember whats an object and whats a column and we can run into subtle errors, or have very confusing lines of codes.\nThus; my final reason for choosing UpperCamelCase:\n\n\nCode\n#create a new example dataframe\nfish &lt;- data.frame(Species = c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n                   FishCountLocation1 = c(6,9,3,5,10),\n                   FishCountLocation2 = c(1,16,3,2,7))\n\n#get the rowwise mean of the fish counts per species\nmean_fish &lt;- fish |&gt; \n  rowwise() |&gt; \n  mutate(mean_fish = mean(c(FishCountLocation1, FishCountLocation2))) |&gt; \n  ungroup()\n\n#print the dataframe\ncond_form_tables(mean_fish)\n\n\n\n\nSpeciesFishCountLocation1FishCountLocation2mean_fish\n\nA613.5\n\nB91612.5\n\nC333  \n\nD523.5\n\nE1078.5\n\n\n\n\n\n\n3 The Function\nMy custom function takes advantage of the janitor R package, which includes a wide range of functions to perform standard cleaning and organisation steps (check out the janitor documentation to see what it can do). Specifically, we are going to use the clean_names() function, along with some bells and whistles to catch our edge cases. Lets take a look:\n\n\nCode\n#create the custom function\nname_cleaning &lt;- function(df){\n\n  #load and install (if required) the pacman package handler package, which we will use for all future package downloads\n  if(!require(\"pacman\")){install.packages(\"pacman\")}\n\n  #use the pacman function to load and install (if required) all other packages\n  pacman::p_load(janitor, dplyr, sf, stringr)\n\n  #check if the df is an sf object and if so, apply clean names to every column but the last column\n  if(inherits(df, \"sf\")){\n    \n    #convert all but the geometry column to upper camel type\n    df_new &lt;- df |&gt; \n      st_drop_geometry() |&gt;\n      clean_names(case = \"upper_camel\")\n    \n    #bind the geometry column back on with its new name. Note that it should also be named \"geom\"\n    df_new &lt;- df_new |&gt;\n      dplyr::mutate(geom = st_geometry(df)) |&gt; \n      st_as_sf()\n  \n  } else {\n    \n    #convert ALL columns to upper camel type, don't have to worry about geometry\n    df_new &lt;- df |&gt; \n      clean_names(case = \"upper_camel\")\n    \n  }\n  \n  #for every character type column, run a encoding check and fix, then remove weird new line characters\n  df_new &lt;- df_new  |&gt; \n    mutate(across(where(is.character), ~ iconv(., from = 'UTF-8', to = 'ASCII//TRANSLIT'))) |&gt; \n    mutate(across(where(is.character), ~str_replace_all(., \"\\r\\n\", \" \")))\n  \n  return(df_new)\n  \n}\n\n\nOk, so even though that is a relatively short function, there is still a few things going on. Lets break it down a bit.\n\nFirst we will initialize the function (if you are unfamiliar with creating your own functions check out my functions post).\n\n\n\nCode\n#initialize the function\nname_cleaning &lt;- function(df){\n\n\n\nThen we load each of our required packages. Noting that generally we would expect these packages to already have been loaded in by the script calling this function, but we can’t be sure. Here we use the pacman package to make the install/load steps a bit more streamline, documentation for pacman can be found here.\n\n\n\nCode\n  #load and install (if required) the pacman package handler package, which we will use for all future package downloads\n  if(!require(\"pacman\")){install.packages(\"pacman\")}\n\n  #use the pacman function to load and install (if required) all other packages\n  pacman::p_load(janitor, dplyr, sf, stringr)\n\n\n\nWe then check if the dataframe we are cleaning is actually an “sf” (simple feature) object. Sf objects are special types of dataframes used in geospatial analytics that have an extra column containing coordinate information. This special column has its own rules for column naming and therefore sf objects should be handled differently. In my work I encounter sf objects very often.\n\n\n\nCode\n  #check if the df is an sf object and if so, apply clean names to every column but the last column\n  if(inherits(df, \"sf\")){\n\n\n\nIf we are looking at an sf object, we copy the sf object and remove the geometry column from this copy. Following this, we can then run janitor’s clean_names() function on the copy with no geometry column. The reason we do this is that the janitor package has no precedent for sf objects. In the clean_names() function, we specify that we want the column names to follow the “upper_camel” format. This will convert all our column names to the desired format.\n\n\n\nCode\n    #convert all but the geometry column to upper camel type\n    df_new &lt;- df |&gt; \n      st_drop_geometry() |&gt;\n      clean_names(case = \"upper_camel\")\n\n\n\nOnce we have cleaned the names of every column in the sf object, we can then add the special geometry column back on to the dataset. At this point we also need to convert the object back to the “sf” type.\n\n\n\n\n\n\n\nNote\n\n\n\nYou may notice that this special geometry column is called “geom” rather than “Geom”… which doesn’t adhere to our naming convention. Unfortunately, this is an annoying quirk of spatial datasets. When they are loaded, the geometry column can take on 1 of 3 different names depending on the source of the data; “geom”, “geometry”, or “shape”. In all cases the name is lowercase, even when the data is saved in uppercase, it will be reloaded in lowercase. Thus, for this issue, we simply ensure that the 3 different possibilities are all just converted to the “geom” option.\n\n\n\n\nCode\n    #bind the geometry column back on with its new name. Note that it should also be named \"geom\"\n    df_new &lt;- df_new |&gt;\n      dplyr::mutate(geom = st_geometry(df)) |&gt; \n      st_as_sf()\n\n\n\nIf the object is a simple dataframe (not an sf object), we can just move straight to the clean_names() step that we explained above.\n\n\n\nCode\n  } else {\n    \n    #convert ALL columns to upper camel type, don't have to worry about geometry\n    df_new &lt;- df |&gt; \n      clean_names(case = \"upper_camel\")\n    \n  }\n\n\n\nNext we look to catch strange edge cases related to the encoding column of columns. You are likely familiar with the concept of a column being of type “character” or “numeric” or “boolean”, etc. Our strange edge case is similar to this. What we have found is that in some instances the character column type is encoded as “UTF-8”, while other times it is encoded as “ASCII”. Much like how you can’t combine character and numeric columns, you also can’t combine columns encoded as UTF-8 and ASCII. Below we convert all columns encoded as UTF-8 to ASCII to avoid this issue.\n\n\n\n\n\n\n\nNote\n\n\n\nPlease note that these encodings are hidden from the user and you will never normally need to interact with them, the reason this happens doesn’t matter, and is frankly some mysterious property of excel. Broadly, you probably don’t need to ever understand why/how this step works.\n\n\n\n\nCode\n  #for every character type column, run a encoding check and fix, then remove weird new line characters\n  df_new &lt;- df_new  |&gt; \n    mutate(across(where(is.character), ~ iconv(., from = 'UTF-8', to = 'ASCII//TRANSLIT'))) |&gt; \n    mutate(across(where(is.character), ~str_replace_all(., \"\\r\\n\", \" \")))\n\n\n\nThe object is then returned and the function is complete.\n\n\n\nCode\n  return(df_new)\n  \n}\n\n\n\n\n4 In Practice\nNow that we understand how the function works, lets demonstrate its use with another example dataset that has a wide range of column names. Here is before:\n\n\nCode\n#create an example table with example names\nexample_df &lt;- data.frame(\"column 1\" = c(1,2,3,4,5),\n                         \"column-2\" = c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n                         \"column_3\" = c(NA, NA, NA, NA, NA),\n                         \"column-four\" = c(\"1A\", \"2B\", \"3C\", \"4D\", \"5E\"),\n                         \"Column Five\" = c(TRUE, FALSE, TRUE, FALSE, TRUE))\n\n#print the table\nprint(example_df)\n\n\n  column.1 column.2 column_3 column.four Column.Five\n1        1        A       NA          1A        TRUE\n2        2        B       NA          2B       FALSE\n3        3        C       NA          3C        TRUE\n4        4        D       NA          4D       FALSE\n5        5        E       NA          5E        TRUE\n\n\nAnd after:\n\n\nCode\n#run the clean name functions\nexample_df_cleaned &lt;- name_cleaning(example_df)\n\n#print the cleaned dataset\ncond_form_tables(example_df_cleaned)\n\n\n\n\nColumn1Column2Column3ColumnFourColumnFive\n\n1A1ATRUE\n\n2B2BFALSE\n\n3C3CTRUE\n\n4D4DFALSE\n\n5E5ETRUE\n\n\n\n\n\n\n5 Caveats\nIt is also important to acknowledge the caveats of your own work. To my knowledge the only caveat of this function is that it relies on a sensible preexisting column name, even if the format is horrible. What I mean by this is that a column named “Mean-fish_in Townsville” can be cleaned, but a column with no name… well how can you rename that to something appropriate? As a side note R does generally replace empty column names with “X1”, “X2”, etc. however this still does not provide any information about the column."
  },
  {
    "objectID": "cv/index.html",
    "href": "cv/index.html",
    "title": "ADAM SHAND",
    "section": "",
    "text": "Document\n\n\n\n  \n    \n      \n    \n      Download Current CV"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, Im Adam.",
    "section": "",
    "text": "Document\n\n\n\n  \n    \n      Hi, Im Adam.\n      An environmental data analyst decoding nature's secrets.\n      \n      \n       With experience in R, Tableau, SQL and GIS, I transform raw environmental data into meaningful narratives with stunning visuals. From crafting data-driven solutions to fostering sustainability, I am dedicated to bridging the gap between technology and the environment."
  },
  {
    "objectID": "posts/going_loopy_for_for_loops/index.html",
    "href": "posts/going_loopy_for_for_loops/index.html",
    "title": "Going Loopy for For Loops",
    "section": "",
    "text": "Here’s the scene, you’ve started on your R coding journey, know how to create an object, how to discern between vectors and lists, maybe even written a few short scripts. Then all of a sudden your professor/teacher/boss pulls a fast one on you and introduces for loops. For loops? What are they? How’s that work? Whats going on? You struggle through and complete the task, but didn’t quite understand what was going on when they explained it to you… Well at least that’s how it went for me.\nIn this post I wanted to quickly talk about for loops in R, specifically, I’m looking to cover:\n\nWhat is really happening in a for loop\nWhere you can go to read about for loops in much (much) more detail\nWhy you might want to write a for loop\nHow you can start to write your own loops\nAnd ironically, why I actually try to avoid using for loops"
  },
  {
    "objectID": "posts/going_loopy_for_for_loops/index.html#i-the-iteration",
    "href": "posts/going_loopy_for_for_loops/index.html#i-the-iteration",
    "title": "Going Loopy for For Loops",
    "section": "2.1 i The Iteration",
    "text": "2.1 i The Iteration\n“i” can be anything, which is not super helpful (sorry). What might be helpful is just seeing an example. This code:\n\n\nCode\n#write a for loop to print the numbers 1 to 10\nfor (PotatoSalad in 1:10){\n  print(PotatoSalad)\n}\n\n\nwill produce the exact same result as this code:\n\n\nCode\n#write a for loop to print the numbers 1 to 10\nfor (i in 1:10){\n  print(i)\n}\n\n\nWe use “i” as an iteration counter (hence usually getting called “i”) that keeps track of what loop we are on with respect to n. For our example above, n is 10. So on the first loop “i” is 1, on the second loop “i” is 2, on the third loop “i” is three…, all the way until “i” is 10. At that point, the for loop finishes. Hopefully it is now intuitive to see how print(i) produces the numbers it does."
  },
  {
    "objectID": "posts/going_loopy_for_for_loops/index.html#n-the-range",
    "href": "posts/going_loopy_for_for_loops/index.html#n-the-range",
    "title": "Going Loopy for For Loops",
    "section": "2.2 n The Range",
    "text": "2.2 n The Range\n“n” is the range of the loop. “n” tells the for loop two things;\n\nHow many times to continue looping\nWhat elements to loop over\n\nIn our example above, n is 10. But wait, that’s not quite right, n is actually 1 to 10. This is an important distinction to make because it is usually one of the first places we make errors. Lets take a look:\n\n\nCode\n#write a for loop to print the number 10 (spot the issue)\nfor (i in 10){\n  print(i)\n}\n\n\n[1] 10\n\n\nAs you can see, when “n” is just 10, then the output is only the value “10”. This is because the range (AKA length) of “n” was only 1. An easy way to check this is to use the length() function:\n\n\nCode\nlength(10)\n\n\n[1] 1\n\n\n\n\nCode\nlength(1:10)\n\n\n[1] 10\n\n\nSo the first super important thing to remember is that “n” is a range, it has a point you want to start at, and a point you want to end at. The second super important thing to remember about “n” is that it directly tells the specific value to start and end at, and therefore determine the value that “i” is going to be. Here is a simple demonstration:\n\n\nCode\n#write a for loop to print the numbers 15 to 22\nfor (i in 15:22){\n  print(i)\n}\n\n\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n[1] 22\n\n\nIn this case, we started at 15 and ended at 22. So on the first loop, “i” is 15, second loop “i” is 16, etc.\nThe last super important thing to remember about “n” does not have to be numeric! It look me a while to realize this, but it can allow you to do some cool things. Here is another quick example:\n\n\nCode\n#create a vector of character elements\nn_range &lt;- c(\"PotatoSalad\", \"FishFingers\", \"Im... Kinda Hungry\")\n\n#write a for loop to print this vector one element at a time\nfor (i in n_range){\n  print(i)\n}\n\n\n[1] \"PotatoSalad\"\n[1] \"FishFingers\"\n[1] \"Im... Kinda Hungry\"\n\n\nThis does through a minor curve ball though. Did you notice that the code is now for (i in n_range), there is no “1:” in front of “n_range”, this is just because the object “n_range” already has a range of elements that we can loop over. Lets use length() again to show this:\n\n\nCode\nlength(n_range)\n\n\n[1] 3\n\n\nIf you can remember these core things about for loops you will get very, very far with them. So to summarise. “n”:\n\nMust be a range, it needs a start and end point\nTells “i” what value it is going to be\nCan be a numeric, or character!"
  },
  {
    "objectID": "posts/going_loopy_for_for_loops/index.html#f-the-function",
    "href": "posts/going_loopy_for_for_loops/index.html#f-the-function",
    "title": "Going Loopy for For Loops",
    "section": "2.3 f The Function",
    "text": "2.3 f The Function\nThe final part of a for loop is by far the biggest part of the code, but it is ironically very straight forward to understand if you have a little bit of an R background. The function or functions inside a for loop are the exact same functions that you would be using outside a for loop! The hard part to figure out is where to place that stupid “i” value. Personally, I haven’t been able to find a method of explaining where “i” goes other than by being very conscious of the purpose of your for loop. Start with simple and short loops and work your way to more complicated tasked, it will come naturally. Generally you will find that “i” only needs to be placed in a few key locations, however if you miss a spot, happy debugging!\n\n\n\n\n\n\nNote\n\n\n\nWant to learn more about For Loops from the professionals? Check out the Iteration chapter in R for Data Science!"
  },
  {
    "objectID": "posts/going_loopy_for_for_loops/index.html#the-scenario",
    "href": "posts/going_loopy_for_for_loops/index.html#the-scenario",
    "title": "Going Loopy for For Loops",
    "section": "3.1 The Scenario",
    "text": "3.1 The Scenario\nSomething I do almost every day is make maps. Usually fairly simple maps, often they show sample site locations, or coral monitoring locations, or the size of a seagrass meadow, things like that. These maps are included in static word documents and are often needed over large chunks of areas. However, the combination of a large study location, a high quantity of sample site locations, and a static output (can’t put an interactive map into word), means that instead of one large map, I need to create lots of small maps for each little area.\nThis here, is an absolutely prime example of a compelling reason to use a for loop. To give you some numbers, in one my projects I need to create 67 maps. If I was to manually write out the code for each of those 67 maps, my script would have 3886 lines of code just dedicated to creating the maps. Instead, I use a for loop and pull 67 maps out of less than 100 lines of code. Not only that, but I also reduce the chance of an error sneaking into my code by 67x.\nBelow is a simplified mock up of the code I would use for this, noting that I have used made up sampling locations for data privacy, and created interactive maps for your enjoyment. We will see the full code in action first, then break it down step by step.\n\n\nCode\n#read in some example data that I made up\nexample_sites &lt;- st_read(\"example_data.gpkg\")\n\n#extract an object that contains the three unique locations we are looking at\nlocations &lt;- unique(example_sites$Location)\n\n#create a list that will store my maps\nlist_of_maps &lt;- setNames(vector(\"list\", length(locations)), locations)\n\n#initialize the for loop\nfor (i in locations){\n  \n  #filter our dataset\n  sub_set_of_sites &lt;- example_sites |&gt; \n    filter(Location == i)\n  \n  #create a simple map\n  single_map &lt;- tm_shape(sub_set_of_sites) +\n    tm_dots(shape = \"Site\", size = 1, col = \"Site\", fill = \"Site\") +\n    tm_text(\"Site\", size = 2, ymod = 1) +\n    tm_layout(legend.show = F)\n  \n  #add each map to the list\n  list_of_maps[[i]] &lt;- single_map\n  \n}\n\n\nHere is how one of the maps looks:\n\n\nCode\n#view the map\nlist_of_maps[[\"Alligator Creek\"]]"
  },
  {
    "objectID": "posts/going_loopy_for_for_loops/index.html#the-breakdown",
    "href": "posts/going_loopy_for_for_loops/index.html#the-breakdown",
    "title": "Going Loopy for For Loops",
    "section": "3.2 The Breakdown",
    "text": "3.2 The Breakdown\nTime to take a closer look at whats happening here.\n\nFirst of all, i use a function called st_read() from the sf package to load in my dataset. For the purposes of this post, we don’t need to worry about this package and its functions. Check out my other posts for more details on this area. What I will do here though, is show a sneak peak of the data.\n\n\n\nCode\n#read in some example data that I made up\nexample_sites &lt;- st_read(\"example_data.gpkg\")\n\n\n\n\n\n\nLocationSiteXY\n\nAlligator CreekSite 1147-19.3\n\nAlligator CreekSite 2147-19.3\n\nAlligator CreekSite 3147-19.3\n\nThe StrandSite 1147-19.2\n\nTown CommonSite 1147-19.2\n\nTown CommonSite 2147-19.2\n\nTown CommonSite 3147-19.2\n\nMagnetic IslandSite 1147-19.2\n\nMagnetic IslandSite 2147-19.2\n\n\n\n\n\nFrom this dataset I then extract a vector of unique locations, which in this case we can easily see is just the four (Alligator Creek, The Strand, Town Common, Magnetic Island).\n\n\n\nCode\n#extract an object that contains the three unique locations we are looking at\nlocations &lt;- unique(example_sites$Location)\n\n\n\nI then create a list to store the outputs of my for loop. This step can be done a wide range of ways, for example you could store each output as a separate object, if you know the number of outputs you could pre-define a list of that length to store the outputs (like I did), or if the number of outputs is a mystery you can grow the list as you go. There is no “best” way to do this, however it is generally frowned upon to grow the list as you go, as this can be computationally quite expensive. My recommendation would be to use the first two options, favoring a list with a pre-defined length if you can.\n\n\n\nCode\n#create a list that will store my maps\nlist_of_maps &lt;- setNames(vector(\"list\", length(locations)), locations)\n\n\n\nThe set up is done and it is now time to begin the for loop. This section of the code is a good time to review what we discussed above. We can see that I am going to loop over “locations”, and for each loop “i” will become of the elements in “locations”.\n\n\n\nCode\n#initialize the for loop\nfor (i in locations){\n\n\n\nWe are now working within the for loop. Remember, this section of the code will be run again and again and again. The first thing we do inside the for loop is take a subset of our data. We can filter the data by “i” because “i” has taken on the first element of “location”.\n\n\n\nCode\n  #filter our dataset\n  sub_set_of_sites &lt;- example_sites |&gt; \n    filter(Location == i)\n\n\n\nUsing the subset of the data, which will now only contains rows from one location thanks to our filter. We then create the map. I like to use the tmap package, however there is a wide range of options available. Maybe I will write a post on mapping with tmap one day… we will see.\n\n\n\nCode\n  #create a simple map\n  single_map &lt;- tm_shape(sub_set_of_sites) +\n    tm_dots(shape = \"Site\", size = 1, col = \"Site\", fill = \"Site\") +\n    tm_text(\"Site\", size = 2, ymod = 1) +\n    tm_layout(legend.show = F)\n\n\n\nThe final step of our for loop is to save the output of the loop somewhere. This step can catch alot of people off guard, they write the perfect loop, they check everything runs properly, and then they forgot to save the output each loop. Shame.\n\nIn my case, I have put the map into the list that we defined earlier. Notice that because I named each item in the list, I can then place the map under the correct item using “i”.\n\n\nCode\n  #add each map to the list\n  list_of_maps[[i]] &lt;- single_map\n  \n}"
  },
  {
    "objectID": "posts/learning_to_create_custom_functions/index.html",
    "href": "posts/learning_to_create_custom_functions/index.html",
    "title": "Learning To Create Your Own Custom Functions",
    "section": "",
    "text": "Main points to hit\n\nwhat are functions really\nwhy would you want to make one\nhow can you go about making a functions\nwhat is a compelling reason - note that often the big ideas are “already taken”, usually your first function is something super specific"
  }
]